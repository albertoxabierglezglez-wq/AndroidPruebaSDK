<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wallet Multi-Red - BSC, ETH Manager</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/brands.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcode-generator/1.4.4/qrcode.min.js"></script>
    <style>
        :root {
            --primary-gold: #D4AF37;
            --gold-light: #F7EF8A;
            --gold-dark: #B8860B;
            --gold-darker: #8B6914;
            --bg-dark: #0F0F0F;
            --bg-card: #1A1A1A;
            --text-light: #F5F5F5;
            --text-gray: #A0A0A0;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --border-radius: 16px;
            --transition: all 0.3s ease;
        }
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        html {
            font-size: 14px;
        }
        body {
            background: linear-gradient(135deg, var(--bg-dark) 0%, #2A1A1F 100%);
            color: var(--text-light);
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            min-height: 100vh;
            line-height: 1.5;
            overflow-x: hidden;
            padding: 0;
        }
        .container {
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 1rem;
        }
        header {
            background: rgba(26, 26, 26, 0.95);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(212, 175, 55, 0.35);
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.3);
            position: sticky;
            top: 0;
            z-index: 100;
            padding: 0.75rem 0;
        }
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 0.75rem;
        }
        .logo {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-shrink: 0;
        }
        .logo i {
            font-size: 1.5rem;
            color: var(--primary-gold);
        }
        .logo h1 {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--primary-gold);
            white-space: nowrap;
        }
        .header-actions {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            flex-wrap: wrap;
            justify-content: flex-end;
        }
        .network-status {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
            padding: 0.4rem 0.8rem;
            border-radius: 50px;
            font-size: 0.8rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 0.4rem;
            white-space: nowrap;
        }
        .network-status i {
            font-size: 0.5rem;
        }
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.6rem 1.2rem;
            border-radius: 10px;
            font-weight: 600;
            text-decoration: none;
            transition: var(--transition);
            border: none;
            cursor: pointer;
            gap: 0.4rem;
            font-size: 0.9rem;
            white-space: nowrap;
        }
        .btn-primary {
            background: linear-gradient(135deg, var(--primary-gold), var(--gold-dark));
            color: #0F0F0F;
            box-shadow: 0 4px 15px rgba(212, 175, 55, 0.4);
        }
        .btn-primary:hover {
            background: linear-gradient(135deg, var(--gold-dark), var(--primary-gold));
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(212, 175, 55, 0.6);
        }
        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-light);
            border: 1px solid rgba(212, 175, 55, 0.3);
        }
        .btn-secondary:hover {
            background: rgba(212, 175, 55, 0.1);
            transform: translateY(-2px);
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }
        .card {
            background: rgba(26, 26, 26, 0.8);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(212, 175, 55, 0.25);
            border-radius: var(--border-radius);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            transition: var(--transition);
            overflow: hidden;
            position: relative;
            width: 100%;
        }
        .card:hover {
            transform: translateY(-5px);
            border-color: var(--primary-gold);
            box-shadow: 0 15px 35px rgba(212, 175, 55, 0.3);
        }
        .balance-card {
            background: linear-gradient(135deg, var(--gold-dark) 0%, var(--primary-gold) 100%);
            color: #0F0F0F;
            position: relative;
            overflow: hidden;
            min-height: 140px;
        }
        .balance-card::after {
            content: '';
            position: absolute;
            top: -50%;
            right: -50%;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(255,255,255,0.25) 0%, transparent 70%);
            transform: rotate(30deg);
        }
        .action-btn {
            transition: var(--transition);
            cursor: pointer;
            min-height: 80px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .action-btn:hover {
            transform: translateY(-3px);
            border-color: var(--primary-gold);
        }
        .network-indicator {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            padding: 0.2rem 0.6rem;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 600;
        }
        .network-indicator.bsc {
            background: rgba(243, 186, 47, 0.2);
            color: #f3ba2f;
            border: 1px solid rgba(243, 186, 47, 0.3);
        }
        .network-indicator.eth {
            background: rgba(105, 120, 255, 0.2);
            color: #6978ff;
            border: 1px solid rgba(105, 120, 255, 0.3);
        }
        .network-badges {
            display: flex;
            justify-content: center;
            gap: 0.75rem;
            flex-wrap: wrap;
            margin: 1rem 0;
        }
        .network-badge {
            padding: 0.4rem 0.8rem;
            border-radius: 16px;
            font-weight: 600;
            font-size: 0.8rem;
        }
        .network-badge.bsc {
            background: rgba(243, 186, 47, 0.2);
            color: #f3ba2f;
            border: 1px solid rgba(243, 186, 47, 0.3);
        }
        .network-badge.eth {
            background: rgba(105, 120, 255, 0.2);
            color: #6978ff;
            border: 1px solid rgba(105, 120, 255, 0.3);
        }
        .grid {
            display: grid;
            gap: 1rem;
        }
        .grid-cols-1 {
            grid-template-columns: 1fr;
        }
        .grid-cols-2 {
            grid-template-columns: repeat(2, 1fr);
        }
        .grid-cols-3 {
            grid-template-columns: repeat(3, 1fr);
        }
        .grid-cols-4 {
            grid-template-columns: repeat(4, 1fr);
        }
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 0.5rem;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .modal.active {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background: var(--bg-card);
            border-radius: var(--border-radius);
            width: 100%;
            max-width: 500px;
            max-height: 95vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            transform: translateY(20px);
            transition: transform 0.3s ease;
        }
        .modal.active .modal-content {
            transform: translateY(0);
        }
        .modal-header {
            padding: 1.25rem;
            border-bottom: 1px solid rgba(212, 175, 55, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .modal-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--primary-gold);
        }
        .modal-body {
            padding: 1.25rem;
        }
        .modal-footer {
            padding: 1.25rem;
            border-top: 1px solid rgba(212, 175, 55, 0.2);
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
            flex-wrap: wrap;
        }
        .form-group {
            margin-bottom: 1.25rem;
        }
        .form-label {
            display: block;
            margin-bottom: 0.4rem;
            font-weight: 500;
            color: var(--text-light);
            font-size: 0.9rem;
        }
        .form-control {
            width: 100%;
            padding: 0.6rem 0.8rem;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(212, 175, 55, 0.4);
            border-radius: 10px;
            color: var(--text-light);
            font-size: 0.9rem;
            transition: var(--transition);
        }
        .form-control:focus {
            outline: none;
            border-color: var(--primary-gold);
            box-shadow: 0 0 0 3px rgba(212, 175, 55, 0.2);
            background: rgba(255, 255, 255, 0.12);
        }
        .form-control::placeholder {
            color: var(--text-gray);
        }
        .form-control:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .validation-message {
            margin-top: 0.4rem;
            padding: 0.4rem;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: 500;
        }
        .validation-message.success {
            background: rgba(16, 185, 129, 0.1);
            color: #10b981;
            border: 1px solid rgba(16, 185, 129, 0.2);
        }
        .validation-message.error {
            background: rgba(239, 68, 68, 0.1);
            color: #ef4444;
            border: 1px solid rgba(239, 68, 68, 0.2);
        }
        .transaction-list {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        .transaction-item {
            background: rgba(26, 26, 26, 0.8);
            border-left: 4px solid;
            border-radius: 10px;
            padding: 0.8rem;
            transition: var(--transition);
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            cursor: pointer;
            word-break: break-word;
        }
        .transaction-item:hover {
            transform: translateX(5px);
            background: rgba(212, 175, 55, 0.1);
        }
        .transaction-item.received {
            border-left-color: var(--success);
        }
        .transaction-item.sent {
            border-left-color: var(--danger);
        }
        .transaction-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            width: 100%;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        .transaction-type-badge {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            font-weight: 600;
            font-size: 0.8rem;
        }
        .transaction-type-badge .success {
            color: #10b981;
        }
        .transaction-type-badge .danger {
            color: #ef4444;
        }
        .transaction-network-badge {
            padding: 0.15rem 0.4rem;
            border-radius: 6px;
            font-size: 0.65rem;
            font-weight: 600;
            margin-left: 0.4rem;
        }
        .network-bsc {
            background: rgba(243, 186, 47, 0.2);
            color: #f3ba2f;
        }
        .network-eth {
            background: rgba(105, 120, 255, 0.2);
            color: #6978ff;
        }
        .transaction-date {
            color: var(--text-gray);
            font-size: 0.75rem;
        }
        .transaction-body {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        .transaction-hash {
            font-family: 'Courier New', monospace;
            font-size: 0.75rem;
            color: var(--text-gray);
            background: rgba(255, 255, 255, 0.05);
            padding: 0.2rem 0.4rem;
            border-radius: 6px;
            word-break: break-all;
        }
        .transaction-amount-section {
            text-align: right;
            flex: 1;
            min-width: 120px;
        }
        .amount {
            font-size: 0.9rem;
            font-weight: 700;
            margin-bottom: 0.2rem;
        }
        .amount.success {
            color: #10b981;
        }
        .amount.danger {
            color: #ef4444;
        }
        .gas-fee {
            font-size: 0.7rem;
            color: var(--text-gray);
        }
        .transaction-footer {
            display: flex;
            justify-content: flex-end;
            width: 100%;
        }
        .transaction-status-badge {
            padding: 0.2rem 0.6rem;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            gap: 0.2rem;
        }
        .status-pending {
            background: rgba(245, 158, 11, 0.2);
            color: #f59e0b;
            border: 1px solid rgba(245, 158, 11, 0.3);
        }
        .status-confirmed {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
            border: 1px solid rgba(16, 185, 129, 0.3);
        }
        .status-failed {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }
        .transaction-filters {
            display: flex;
            gap: 0.75rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }
        .network-filter, .type-filter {
            display: flex;
            gap: 0.4rem;
            flex-wrap: wrap;
        }
        .filter-btn {
            padding: 0.4rem 0.8rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(212, 175, 55, 0.3);
            border-radius: 8px;
            color: var(--text-gray);
            cursor: pointer;
            transition: var(--transition);
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            gap: 0.4rem;
            white-space: nowrap;
        }
        .filter-btn:hover {
            background: rgba(212, 175, 55, 0.1);
            color: var(--text-light);
        }
        .filter-btn.active {
            background: rgba(212, 175, 55, 0.2);
            color: var(--primary-gold);
            border-color: var(--primary-gold);
        }
        .transaction-pagination {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 1.25rem;
            padding-top: 1rem;
            border-top: 1px solid rgba(212, 175, 55, 0.2);
            flex-wrap: wrap;
            gap: 0.75rem;
        }
        .pagination-btn {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.4rem 0.8rem;
            background: rgba(212, 175, 55, 0.1);
            border: 1px solid rgba(212, 175, 55, 0.3);
            border-radius: 8px;
            color: var(--primary-gold);
            cursor: pointer;
            transition: var(--transition);
            font-size: 0.8rem;
            font-weight: 500;
            white-space: nowrap;
        }
        .pagination-btn:hover:not(:disabled) {
            background: rgba(212, 175, 55, 0.2);
            transform: translateY(-1px);
        }
        .pagination-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .page-info {
            color: var(--text-light);
            font-size: 0.8rem;
            font-weight: 500;
        }
        .no-transactions {
            text-align: center;
            padding: 2rem 1rem;
            color: var(--text-gray);
        }
        .no-transactions i {
            font-size: 2.5rem;
            opacity: 0.3;
            margin-bottom: 0.75rem;
        }
        .no-transactions h4 {
            font-size: 1rem;
            margin-bottom: 0.4rem;
            color: var(--text-light);
        }
        .no-transactions p {
            margin-bottom: 1.25rem;
            font-size: 0.9rem;
        }
        .toast-container {
            position: fixed;
            top: 0.5rem;
            right: 0.5rem;
            z-index: 1100;
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
            max-width: calc(100vw - 1rem);
        }
        .toast {
            background: var(--bg-card);
            border: 1px solid rgba(212, 175, 55, 0.4);
            border-radius: 10px;
            padding: 0.8rem;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.4);
            display: flex;
            align-items: center;
            gap: 0.6rem;
            animation: slideInRight 0.3s ease;
            position: relative;
            overflow: hidden;
            max-width: 100%;
        }
        .toast::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: 4px;
        }
        .toast.success::before {
            background: var(--success);
        }
        .toast.error::before {
            background: var(--danger);
        }
        .toast.warning::before {
            background: var(--warning);
        }
        .toast.info::before {
            background: var(--primary-gold);
        }
        .toast-icon {
            font-size: 1.1rem;
            flex-shrink: 0;
        }
        .toast.success .toast-icon {
            color: var(--success);
        }
        .toast.error .toast-icon {
            color: var(--danger);
        }
        .toast.warning .toast-icon {
            color: var(--warning);
        }
        .toast.info .toast-icon {
            color: var(--primary-gold);
        }
        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        .gas-options {
            display: flex;
            flex-direction: column;
            gap: 0.6rem;
            margin-top: 1rem;
        }
        .gas-option {
            background: rgba(40, 40, 40, 0.8);
            border: 2px solid rgba(212, 175, 55, 0.35);
            border-radius: 8px;
            padding: 0.8rem;
            cursor: pointer;
            transition: var(--transition);
            width: 100%;
        }
        .gas-option:hover {
            border-color: var(--primary-gold);
            background: rgba(212, 175, 55, 0.15);
            transform: translateY(-2px);
        }
        .gas-option.selected {
            border-color: var(--primary-gold);
            background: rgba(212, 175, 55, 0.25);
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.4);
        }
        .gas-option-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        .gas-option-main {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 0.2rem;
        }
        .gas-option-label {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-light);
        }
        .gas-option-time {
            font-size: 0.8rem;
            color: var(--text-gray);
        }
        .gas-option-price {
            font-size: 0.9rem;
            font-weight: 700;
            color: var(--primary-gold);
        }
        .gas-option-placeholder {
            text-align: center;
            padding: 1.5rem;
            color: var(--text-gray);
            font-style: italic;
            font-size: 0.9rem;
        }
        .balance-main {
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
        }
        .native-balance {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--text-light);
            word-break: break-word;
        }
        .usdt-balance {
            font-size: 0.9rem;
            color: var(--text-gray);
        }
        .no-wallet {
            font-size: 0.9rem;
            color: var(--text-gray);
            font-style: italic;
        }
        .multichain-import-container,
        .multichain-backup-container {
            max-height: 70vh;
            overflow-y: auto;
        }
        .network-buttons,
        .backup-network-tabs,
        .import-method-tabs,
        .receive-network-tabs {
            display: flex;
            gap: 0.4rem;
            margin-bottom: 1.25rem;
            flex-wrap: wrap;
        }
        .network-btn,
        .backup-tab-btn,
        .import-tab-btn,
        .receive-tab-btn {
            flex: 1;
            min-width: 80px;
            padding: 0.6rem 0.8rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(212, 175, 55, 0.3);
            border-radius: 8px;
            color: var(--text-gray);
            cursor: pointer;
            transition: var(--transition);
            text-align: center;
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.4rem;
            font-size: 0.8rem;
        }
        .network-btn:hover,
        .backup-tab-btn:hover,
        .import-tab-btn:hover,
        .receive-tab-btn:hover {
            background: rgba(212, 175, 55, 0.1);
            color: var(--text-light);
        }
        .network-btn.active,
        .backup-tab-btn.active,
        .import-tab-btn.active,
        .receive-tab-btn.active {
            background: rgba(212, 175, 55, 0.2);
            color: var(--primary-gold);
            border-color: var(--primary-gold);
        }
        .import-method-content,
        .backup-network-content,
        .receive-network-content {
            display: none;
        }
        .import-method-content.active,
        .backup-network-content.active,
        .receive-network-content.active {
            display: block;
        }
        .import-type-buttons {
            display: flex;
            gap: 0.4rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }
        .import-type-btn {
            flex: 1;
            padding: 0.6rem 0.8rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(212, 175, 55, 0.3);
            border-radius: 8px;
            color: var(--text-gray);
            cursor: pointer;
            transition: var(--transition);
            text-align: center;
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.4rem;
            font-size: 0.8rem;
            min-width: 120px;
        }
        .import-type-btn:hover {
            background: rgba(212, 175, 55, 0.1);
        }
        .import-type-btn.active {
            background: rgba(212, 175, 55, 0.2);
            color: var(--primary-gold);
            border-color: var(--primary-gold);
        }
        .import-actions {
            display: flex;
            gap: 0.75rem;
            margin-top: 1.25rem;
            flex-wrap: wrap;
        }
        .import-actions .btn {
            flex: 1;
            min-width: 120px;
        }
        .file-drop-zone {
            border: 2px dashed rgba(212, 175, 55, 0.4);
            border-radius: 10px;
            padding: 1.5rem;
            text-align: center;
            transition: var(--transition);
            margin-bottom: 1rem;
            cursor: pointer;
        }
        .file-drop-zone:hover {
            border-color: var(--primary-gold);
            background: rgba(212, 175, 55, 0.05);
        }
        .file-drop-zone.dragover {
            border-color: var(--primary-gold);
            background: rgba(212, 175, 55, 0.1);
        }
        .file-info {
            background: rgba(212, 175, 55, 0.1);
            border: 1px solid rgba(212, 175, 55, 0.3);
            border-radius: 8px;
            padding: 0.8rem;
            margin-bottom: 1rem;
            word-break: break-word;
        }
        .file-details {
            margin-bottom: 0.8rem;
            line-height: 1.5;
            font-size: 0.9rem;
        }
        .sensitive-data-hidden,
        .sensitive-data-visible {
            transition: all 0.3s ease;
        }
        .btn-reveal, .btn-hide {
            padding: 0.2rem 0.4rem;
            border-radius: 6px;
            font-size: 0.7rem;
            font-weight: 600;
            transition: all 0.2s ease;
            border: 1px solid transparent;
            background: transparent;
            color: inherit;
            cursor: pointer;
        }
        .btn-reveal:hover {
            border-color: rgba(212, 175, 55, 0.3);
            background: rgba(212, 175, 55, 0.1);
        }
        .btn-hide:hover {
            border-color: rgba(239, 68, 68, 0.3);
            background: rgba(239, 68, 68, 0.1);
        }
        .select-all {
            user-select: all;
            -webkit-user-select: all;
            -moz-user-select: all;
            -ms-user-select: all;
        }
        .security-warning {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: 8px;
            padding: 0.8rem;
            display: flex;
            align-items: flex-start;
            gap: 0.6rem;
            margin-top: 1rem;
        }
        .security-warning i {
            color: #ef4444;
            margin-top: 0.1rem;
            flex-shrink: 0;
        }
        .security-warning p {
            margin: 0;
            font-size: 0.8rem;
            color: var(--text-light);
            line-height: 1.4;
        }
        .transaction-details {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        .detail-item {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 0.4rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        .detail-item:last-child {
            border-bottom: none;
        }
        .detail-item strong {
            color: var(--primary-gold);
            min-width: 100px;
            font-size: 0.9rem;
        }
        .detail-value {
            text-align: right;
            word-break: break-all;
            flex: 1;
            margin-left: 0.75rem;
            font-size: 0.9rem;
        }
        .text-center {
            text-align: center;
        }
        .text-gold {
            color: var(--primary-gold);
        }
        .text-success {
            color: var(--success);
        }
        .text-danger {
            color: var(--danger);
        }
        .mb-2 {
            margin-bottom: 0.5rem;
        }
        .mb-4 {
            margin-bottom: 1rem;
        }
        .mb-6 {
            margin-bottom: 1.5rem;
        }
        .mt-4 {
            margin-top: 1rem;
        }
        .mt-6 {
            margin-top: 1.5rem;
        }
        .p-4 {
            padding: 1rem;
        }
        .p-6 {
            padding: 1.5rem;
        }
        .hidden {
            display: none !important;
        }
        .flex {
            display: flex;
        }
        .items-center {
            align-items: center;
        }
        .justify-between {
            justify-content: space-between;
        }
        .w-full {
            width: 100%;
        }
        .gap-2 {
            gap: 0.5rem;
        }
        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .loading {
            display: inline-block;
            width: 18px;
            height: 18px;
            border: 2px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: var(--primary-gold);
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        @media (max-width: 640px) {
            html {
                font-size: 13px;
            }
            .container {
                padding: 0 0.5rem;
            }
            .header-content {
                flex-direction: column;
                text-align: center;
                gap: 0.5rem;
            }
            .logo h1 {
                font-size: 1.1rem;
            }
            .header-actions {
                justify-content: center;
                width: 100%;
            }
            .grid-cols-2,
            .grid-cols-3,
            .grid-cols-4 {
                grid-template-columns: 1fr;
            }
            .modal-content {
                margin: 0.25rem;
                width: calc(100% - 0.5rem);
                max-height: 98vh;
            }
            .transaction-item {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.4rem;
                padding: 0.6rem;
            }
            .transaction-header,
            .transaction-body,
            .transaction-footer {
                width: 100%;
            }
            .transaction-amount-section {
                text-align: left;
                width: 100%;
            }
            .toast-container {
                top: 0.25rem;
                right: 0.25rem;
                left: 0.25rem;
                max-width: none;
            }
            .transaction-filters {
                flex-direction: column;
                gap: 0.4rem;
            }
            .network-filter,
            .type-filter {
                justify-content: center;
            }
            .transaction-pagination {
                flex-direction: column;
                gap: 0.75rem;
            }
            .pagination-btn {
                width: 100%;
                justify-content: center;
            }
            .network-buttons,
            .backup-network-tabs,
            .import-method-tabs,
            .receive-network-tabs {
                flex-direction: column;
            }
            .import-type-buttons {
                flex-direction: column;
            }
            .import-actions {
                flex-direction: column;
            }
            .modal-footer {
                flex-direction: column;
            }
            .modal-footer .btn {
                width: 100%;
            }
            .detail-item {
                flex-direction: column;
                gap: 0.2rem;
            }
            .detail-item strong {
                min-width: auto;
            }
            .detail-value {
                text-align: left;
                margin-left: 0;
            }
            .balance-card {
                min-height: 120px;
                padding: 1rem !important;
            }
            .native-balance {
                font-size: 1.1rem;
            }
            .action-btn {
                min-height: 70px;
                padding: 0.8rem !important;
            }
            .btn {
                padding: 0.5rem 1rem;
                font-size: 0.85rem;
            }
        }
        @media (min-width: 641px) and (max-width: 768px) {
            .grid-cols-3 {
                grid-template-columns: repeat(2, 1fr);
            }
            .grid-cols-4 {
                grid-template-columns: repeat(2, 1fr);
            }
            .modal-content {
                margin: 1rem;
            }
        }
        @media (min-width: 769px) and (max-width: 1024px) {
            .grid-cols-3 {
                grid-template-columns: repeat(2, 1fr);
            }
            .grid-cols-4 {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        @media (min-width: 1025px) {
            html {
                font-size: 16px;
            }
        }
        .resource-bar {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            height: 6px;
            overflow: hidden;
            position: relative;
        }
        .resource-fill {
            height: 100%;
            border-radius: 8px;
            transition: width 0.3s ease;
            position: relative;
        }
        .resource-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shimmer 2s infinite;
        }
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        .resource-low { color: #ef4444; }
        .resource-medium { color: #f59e0b; }
        .resource-high { color: #10b981; }
        .disconnect-popup .swal2-popup {
            border: 2px solid rgba(239, 68, 68, 0.3) !important;
        }
        .disconnect-popup .swal2-confirm {
            background: linear-gradient(135deg, #ef4444, #dc2626) !important;
            border: none !important;
        }
        .disconnect-popup .swal2-confirm:hover {
            background: linear-gradient(135deg, #dc2626, #ef4444) !important;
            transform: translateY(-2px);
        }
        input[readonly] {
            cursor: default;
            font-size: 0.85rem;
        }
        .text-truncate {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .text-break {
            word-break: break-word;
            overflow-wrap: break-word;
        }
        .btn-sm i {
            font-size: 0.8em;
        }
        @media (max-width: 360px) {
            html {
                font-size: 12px;
            }
            .container {
                padding: 0 0.25rem;
            }
            .logo h1 {
                font-size: 1rem;
            }
            .btn {
                padding: 0.4rem 0.8rem;
                font-size: 0.8rem;
            }
            .card {
                border-radius: 12px;
            }
            .modal-content {
                margin: 0.125rem;
                width: calc(100% - 0.25rem);
            }
        }
        @media (min-width: 1440px) {
            .container {
                max-width: 1400px;
            }
            html {
                font-size: 18px;
            }
        }
        .balance-card {
            position: relative;
            min-height: 160px;
            padding: 1.5rem !important;
            z-index: 1;
        }
        .network-indicator {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            z-index: 10;
            padding: 0.3rem 0.8rem;
            font-size: 0.75rem;
        }
        .balance-main {
            margin-top: 0.5rem;
            position: relative;
            z-index: 2;
        }
        .balance-card h3 {
            display: block;
            width: 100%;
        }
        .balance-card .flex {
            align-items: flex-start;
            position: relative;
            z-index: 2;
        }
        .balance-card i {
            font-size: 2rem !important;
            margin-top: 0.5rem;
            opacity: 0.9;
        }
        /* Estilos para el sistema de pestañas avanzado */
.transaction-tabs {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1rem;
    flex-wrap: wrap;
    border-bottom: 1px solid rgba(212, 175, 55, 0.2);
    padding-bottom: 0.5rem;
}

.tab-btn {
    display: flex;
    align-items: center;
    gap: 0.4rem;
    padding: 0.6rem 1rem;
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(212, 175, 55, 0.3);
    border-radius: 8px;
    color: var(--text-gray);
    cursor: pointer;
    transition: var(--transition);
    font-size: 0.8rem;
    font-weight: 500;
    position: relative;
}

.tab-btn:hover {
    background: rgba(212, 175, 55, 0.1);
    color: var(--text-light);
    transform: translateY(-1px);
}

.tab-btn.active {
    background: rgba(212, 175, 55, 0.2);
    color: var(--primary-gold);
    border-color: var(--primary-gold);
    box-shadow: 0 2px 8px rgba(212, 175, 55, 0.3);
}

.filter-badge {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    min-width: 20px;
    height: 20px;
    background: var(--primary-gold);
    color: #0F0F0F;
    border-radius: 10px;
    font-size: 0.7rem;
    font-weight: 600;
    margin-left: 0.3rem;
    padding: 0 0.4rem;
}

.tab-btn.active .filter-badge {
    background: #0F0F0F;
    color: var(--primary-gold);
}

.transaction-filters {
    display: flex;
    gap: 1rem;
    margin-bottom: 1rem;
    flex-wrap: wrap;
}

.network-filter, .type-filter {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
}

.filter-btn {
    display: flex;
    align-items: center;
    gap: 0.4rem;
    padding: 0.5rem 0.8rem;
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(212, 175, 55, 0.3);
    border-radius: 8px;
    color: var(--text-gray);
    cursor: pointer;
    transition: var(--transition);
    font-size: 0.8rem;
    font-weight: 500;
    position: relative;
}

.filter-btn:hover {
    background: rgba(212, 175, 55, 0.1);
    color: var(--text-light);
    transform: translateY(-1px);
}

.filter-btn.active {
    background: rgba(212, 175, 55, 0.2);
    color: var(--primary-gold);
    border-color: var(--primary-gold);
}

.advanced-filters {
    background: rgba(26, 26, 26, 0.6);
    border: 1px solid rgba(212, 175, 55, 0.2);
    border-radius: 8px;
    padding: 0.8rem;
    margin-bottom: 1rem;
}

.filter-group {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.filter-label {
    font-size: 0.8rem;
    font-weight: 600;
    color: var(--primary-gold);
    margin-bottom: 0.3rem;
}

.filter-buttons {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
}

/* Estados de transacciones */
.status-pending {
    background: rgba(245, 158, 11, 0.2);
    color: #f59e0b;
    border: 1px solid rgba(245, 158, 11, 0.3);
}

.status-confirmed {
    background: rgba(16, 185, 129, 0.2);
    color: #10b981;
    border: 1px solid rgba(16, 185, 129, 0.3);
}

.status-failed {
    background: rgba(239, 68, 68, 0.2);
    color: #ef4444;
    border: 1px solid rgba(239, 68, 68, 0.3);
}

/* Responsive */
@media (max-width: 768px) {
    .transaction-tabs {
        flex-direction: column;
        gap: 0.3rem;
    }
    
    .tab-btn {
        justify-content: center;
        padding: 0.5rem 0.8rem;
    }
    
    .transaction-filters {
        flex-direction: column;
        gap: 0.5rem;
    }
    
    .network-filter, .type-filter {
        justify-content: center;
    }
    
    .filter-buttons {
        justify-content: center;
    }
    
    .filter-btn {
        flex: 1;
        min-width: 120px;
        justify-content: center;
    }
}

@media (max-width: 480px) {
    .transaction-tabs {
        gap: 0.2rem;
    }
    
    .tab-btn {
        font-size: 0.75rem;
        padding: 0.4rem 0.6rem;
    }
    
    .filter-badge {
        min-width: 18px;
        height: 18px;
        font-size: 0.65rem;
    }
    
    .advanced-filters {
        padding: 0.6rem;
    }
    
    .filter-buttons {
        gap: 0.3rem;
    }
    
    .filter-btn {
        font-size: 0.75rem;
        padding: 0.4rem 0.6rem;
    }
}
.earn-content {
    display: none;
}

.earn-content.active {
    display: block;
}

.earn-tab.active {
    background: linear-gradient(135deg, var(--primary-gold), var(--gold-dark));
    color: #0F0F0F;
}
/* Agregar al final de los estilos existentes */
.earn-content {
    display: none;
    animation: fadeIn 0.3s ease-in;
}

.earn-content.active {
    display: block;
}

.earn-tab-btn {
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(212, 175, 55, 0.3);
    color: var(--text-gray);
    transition: var(--transition);
    flex: 1;
}

.earn-tab-btn.active {
    background: linear-gradient(135deg, var(--primary-gold), var(--gold-dark));
    color: #0F0F0F;
    border-color: var(--primary-gold);
    transform: translateY(-1px);
}

.earn-tab-btn:hover:not(.active) {
    background: rgba(212, 175, 55, 0.1);
    color: var(--text-light);
}

/* Animaciones para los números APY */
@keyframes pulse-green {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
}

.text-green-400 {
    animation: pulse-green 2s infinite;
}

/* Responsive */
@media (max-width: 768px) {
    .earn-network-tabs .flex {
        flex-direction: column;
    }
    
    .earn-tab-btn {
        width: 100%;
        margin-bottom: 0.5rem;
    }
    
    .grid.grid-cols-2.md\\:grid-cols-4 {
        grid-template-columns: repeat(2, 1fr);
    }
}

@media (max-width: 480px) {
    .grid.grid-cols-2.md\\:grid-cols-4 {
        grid-template-columns: 1fr;
    }
}
/* AGREGAR en la sección de estilos */
.network-buttons {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1rem;
}

.network-btn {
    flex: 1;
    padding: 0.5rem 0.8rem;
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(212, 175, 55, 0.3);
    border-radius: 8px;
    color: var(--text-gray);
    cursor: pointer;
    transition: var(--transition);
    text-align: center;
    font-weight: 500;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.4rem;
    font-size: 0.8rem;
}

.network-btn:hover {
    background: rgba(212, 175, 55, 0.1);
    color: var(--text-light);
}

.network-btn.active {
    background: rgba(212, 175, 55, 0.2);
    color: var(--primary-gold);
    border-color: var(--primary-gold);
}

/* Responsive para Compound */
@media (max-width: 768px) {
    .network-buttons {
        flex-direction: column;
    }
    
    .network-btn {
        width: 100%;
    }
}
    </style>
</head>
<body>
    <div id="toastContainer" class="toast-container"></div>
    
    <header>
        <div class="container">
            <div class="header-content">
                <div class="logo">
                    <i class="fab fa-ethereum"></i>
                    <h1>Wallet Multi-Red AXGG®</h1>
                </div>
                <div class="header-actions">
                    <span class="network-status">
                        <i class="fas fa-circle"></i> 
                        <span id="connectionStatus">Conectando...</span>
                    </span>
                    <button id="connectWalletBtn" class="btn btn-primary">
                        <i class="fas fa-wallet"></i>Conectar Wallets
                    </button>
                </div>
            </div>
        </div>
    </header>

    <main class="container">
        <div id="setupScreen" class="text-center fade-in" style="max-width: 500px; margin: 2rem auto;">
            <div class="card p-6">
                <i class="fas fa-wallet text-gold" style="font-size: 3.5rem; margin-bottom: 1rem;"></i>
                <h2 class="text-gold mb-2" style="font-size: 1.5rem; font-weight: 700;">Wallet Multi-Red AXGG®</h2>
                <p class="mb-6" style="color: var(--text-gray); font-size: 0.95rem;">Gestiona BSC y Ethereum en una sola wallet</p>
                
                <div class="network-badges mb-6">
                    <span class="network-badge bsc">BSC</span>
                    <span class="network-badge eth">ETH</span>
                </div>
                
                <div style="display: flex; flex-direction: column; gap: 0.8rem;">
                    <button id="createWalletBtn" class="btn btn-primary w-full">
                        <i class="fas fa-plus-circle"></i>Crear Wallets Multi-Red
                    </button>
                    <button id="importWalletBtn" class="btn btn-secondary w-full">
                        <i class="fas fa-file-import"></i>Importar Wallets
                    </button>
                </div>
                
                <div class="mt-6 p-4 bg-gray-800 rounded-lg">
                    <p class="text-sm text-gray-400" style="font-size: 0.85rem; line-height: 1.4;">
                        <i class="fas fa-info-circle mr-1"></i>
                        Se crearan wallets separadas para BSC y Ethereum automaticamente
                    </p>
                </div>
            </div>
        </div>

        <div id="dashboard" class="hidden fade-in">
            <div class="card p-6 mb-6">
                <div class="flex justify-between items-center">
                    <div>
                        <p style="color: var(--text-gray); font-weight: 500; font-size: 0.95rem;">Balance Total</p>
                        <h3 id="totalBalance" class="my-2" style="font-size: 1.75rem; font-weight: 700;">$0.00 USD</h3>
                    </div>
                    <i class="fas fa-chart-pie text-gold" style="font-size: 2rem;"></i>
                </div>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                <div id="bscBalanceCard" class="card balance-card p-4">
                    <div class="network-indicator bsc">BSC</div>
                    <div class="flex justify-between items-start">
                        <div style="width: 100%;">
                            <p style="color: rgba(0,0,0,0.7); font-weight: 500; font-size: 0.9rem;">Saldo BSC</p>
                            <h3 id="bscBalance" class="my-2" style="font-size: 1.25rem; font-weight: 700;">
                                <div class="balance-main">
                                    <div class="no-wallet">No conectada</div>
                                </div>
                            </h3>
                            <p id="bscUsdValue" style="color: rgba(0,0,0,0.7); font-weight: 500; font-size: 0.85rem;">$0.00 USD</p>
                        </div>
                        <i class="fab fa-ethereum" style="font-size: 1.75rem; opacity: 0.8;"></i>
                    </div>
                </div>
                
                <div id="ethBalanceCard" class="card balance-card p-4">
                    <div class="network-indicator eth">ETH</div>
                    <div class="flex justify-between items-start">
                        <div style="width: 100%;">
                            <p style="color: rgba(0,0,0,0.7); font-weight: 500; font-size: 0.9rem;">Saldo ETH</p>
                            <h3 id="ethBalance" class="my-2" style="font-size: 1.25rem; font-weight: 700;">
                                <div class="balance-main">
                                    <div class="no-wallet">No conectada</div>
                                </div>
                            </h3>
                            <p id="ethUsdValue" style="color: rgba(0,0,0,0.7); font-weight: 500; font-size: 0.85rem;">$0.00 USD</p>
                        </div>
                        <i class="fab fa-ethereum" style="font-size: 1.75rem; opacity: 0.8;"></i>
                    </div>
                </div>
            </div>

            <div class="grid grid-cols-2 md:grid-cols-4 gap-3 mb-6">
                <button id="sendBtn" class="card p-3 text-center action-btn">
                    <i class="fas fa-paper-plane text-gold mb-1" style="font-size: 1.5rem;"></i>
                    <p style="font-weight: 500; font-size: 0.9rem;">Enviar</p>
                </button>
                
                <button id="receiveBtn" class="card p-3 text-center action-btn">
                    <i class="fas fa-qrcode text-success mb-1" style="font-size: 1.5rem;"></i>
                    <p style="font-weight: 500; font-size: 0.9rem;">Recibir</p>
                </button>
                 <button id="earnBtn" class="card p-3 text-center action-btn">
        <i class="fas fa-chart-line text-green-500 mb-1" style="font-size: 1.5rem;"></i>
        <p style="font-weight: 500; font-size: 0.9rem;">Earn</p>
    </button>
                <button id="backupBtn" class="card p-3 text-center action-btn">
                    <i class="fas fa-shield-alt text-purple-500 mb-1" style="font-size: 1.5rem;"></i>
                    <p style="font-weight: 500; font-size: 0.9rem;">Backup</p>
                </button>
                
                <button id="disconnectBtn" class="card p-3 text-center action-btn">
                    <i class="fas fa-sign-out-alt text-danger mb-1" style="font-size: 1.5rem;"></i>
                    <p style="font-weight: 500; font-size: 0.9rem;">Desconectar</p>
                </button>
            </div>

<!-- HISTORIAL DE TRANSACCIONES - VERSIÓN SIMPLIFICADA -->
<div class="card p-4 mb-6">
    <!-- Encabezado con contador -->
    <div class="flex justify-between items-center mb-4">
        <h3 class="text-gold" style="font-size: 1.1rem; font-weight: 700;">Historial de Transacciones</h3>
        <div class="flex items-center gap-2">
            <span id="transactionCount" class="transaction-count" style="font-size: 0.85rem;">
                <span id="filteredCount">0</span> transacciones
            </span>
            <button id="refreshHistoryBtn" class="text-gold hover:text-yellow-300 transition-colors">
                <i class="fas fa-sync-alt" style="font-size: 0.9rem;"></i>
            </button>
        </div>
    </div>

    <!-- FILTROS SIMPLIFICADOS -->
    <div class="transaction-filters mb-4">
        <!-- Filtro por Estado -->
        <div class="type-filter">
            <button class="filter-btn active" data-type="all">
                <i class="fas fa-list"></i> Todas
                <span class="filter-badge" data-type="all">0</span>
            </button>
            <button class="filter-btn" data-type="received">
                <i class="fas fa-arrow-down"></i> Recibido
                <span class="filter-badge" data-type="received">0</span>
            </button>
            <button class="filter-btn" data-type="sent">
                <i class="fas fa-arrow-up"></i> Enviado
                <span class="filter-badge" data-type="sent">0</span>
            </button>
            <button class="filter-btn" data-type="confirmed">
                <i class="fas fa-check-circle"></i> Confirmado
                <span class="filter-badge" data-type="confirmed">0</span>
            </button>
            <button class="filter-btn" data-type="pending">
                <i class="fas fa-clock"></i> Pendiente
                <span class="filter-badge" data-type="pending">0</span>
            </button>
            <button class="filter-btn" data-type="failed">
                <i class="fas fa-times-circle"></i> Fallido
                <span class="filter-badge" data-type="failed">0</span>
            </button>
        </div>

        <!-- Filtro por Red -->
        <div class="network-filter">
            <button class="filter-btn active" data-network="all">
                <i class="fas fa-layer-group"></i> Todas
                <span class="filter-badge" data-network="all">0</span>
            </button>
            <button class="filter-btn" data-network="BSC">
                <i class="fab fa-bootstrap"></i> BSC
                <span class="filter-badge" data-network="BSC">0</span>
            </button>
            <button class="filter-btn" data-network="ETH">
                <i class="fab fa-ethereum"></i> ETH
                <span class="filter-badge" data-network="ETH">0</span>
            </button>
        </div>
    </div>

    <!-- Lista de transacciones -->
    <div id="transactionHistory" class="transaction-list">
        <div class="no-transactions">
            <i class="fas fa-exchange-alt"></i>
            <h4>No hay transacciones para mostrar</h4>
            <p>Realiza tu primera transacción para ver el historial</p>
        </div>
    </div>

    <!-- Paginación -->
    <div id="transactionPagination" class="transaction-pagination hidden">
        <button id="prevPageBtn" class="pagination-btn">
            <i class="fas fa-chevron-left"></i> Anterior
        </button>
        <span id="pageInfo" class="page-info">Página 1 de 1</span>
        <button id="nextPageBtn" class="pagination-btn">
            Siguiente <i class="fas fa-chevron-right"></i>
        </button>
    </div>
</div>
        </div>
    </main>

    <div id="sendModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Enviar Fondos</h3>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Seleccionar Red</label>
                    <select id="sendNetworkSelect" class="form-control">
                        <option value="">Selecciona una red</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Seleccionar Token</label>
                    <select id="sendTokenSelect" class="form-control" disabled>
                        <option value="">Primero selecciona una red</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Direccion Destino</label>
                    <input type="text" id="sendToAddress" class="form-control" placeholder="0x... o T...">
                    <div id="addressValidation" class="validation-message hidden"></div>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Cantidad</label>
                    <input type="number" id="sendAmount" class="form-control" placeholder="0.0" step="any" disabled>
                    <div class="flex justify-between mt-2" style="font-size: 0.875rem; color: var(--text-gray);">
                        <span>Disponible: <span id="sendMaxAmount">0.0</span></span>
                        <button id="sendMaxBtn" class="text-gold" disabled>Maximo</button>
                    </div>
                </div>
                
                <div class="form-group" id="gasOptionsGroup">
                    <label class="form-label">Velocidad de Transaccion</label>
                    <div class="gas-options" id="gasOptionsContainer">
                        <div class="gas-option-placeholder">
                            Selecciona una red para ver las opciones de gas
                        </div>
                    </div>
                </div>
                
                <div class="card p-4" id="feeSummary">
                    <div class="flex justify-between mb-2" style="font-size: 0.875rem;">
                        <span style="color: var(--text-gray);">Tarifa de red:</span>
                        <span id="sendGasFee" style="font-weight: 500;">-</span>
                    </div>
                    <div class="flex justify-between mb-2" style="font-size: 0.875rem;">
                        <span style="color: var(--text-gray);">Tarifa de red (USD):</span>
                        <span id="sendGasFeeUsd" style="font-weight: 500;">-</span>
                    </div>
                    <div class="flex justify-between mb-2" style="font-size: 0.875rem;">
                        <span style="color: var(--text-gray);">Monto a enviar (USD):</span>
                        <span id="sendAmountUsd" style="font-weight: 500;">-</span>
                    </div>
                    <div class="flex justify-between" style="font-size: 0.875rem;">
                        <span style="color: var(--text-gray);">Total a enviar:</span>
                        <span id="sendTotal" style="font-weight: 500; text-align: right;">-</span>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button id="cancelSendBtn" class="btn btn-secondary">Cancelar</button>
                <button id="confirmSendBtn" class="btn btn-primary" disabled>
                    <span id="confirmSendText">Enviar</span>
                    <span id="confirmSendLoading" class="loading hidden"></span>
                </button>
            </div>
        </div>
    </div>

    <div id="receiveModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Recibir Fondos</h3>
            </div>
            <div class="modal-body">
                <div class="receive-network-tabs">
                    <button class="receive-tab-btn active" data-network="BSC">BSC</button>
                    <button class="receive-tab-btn" data-network="ETH">ETH</button>
                </div>
                
                <div class="receive-content">
                    <div class="receive-network-content active" id="receive-BSC">
                        <div class="text-center">
                            <div id="qrCodeBSC" class="mb-4" style="display: flex; justify-content: center;"></div>
                            <div class="form-group">
                                <label class="form-label">Tu direccion BSC</label>
                                <div class="flex items-center">
                                    <input type="text" id="receiveAddressBSC" class="form-control" readonly>
                                    <button class="btn btn-secondary copy-address-btn" data-network="BSC" style="margin-left: 0.5rem;">
                                        <i class="fas fa-copy"></i>
                                    </button>
                                </div>
                            </div>
                            <p style="color: var(--text-gray); font-size: 0.875rem; margin-top: 1rem;">
                                Comparte esta direccion para recibir BNB o USDT en BSC Mainnet
                            </p>
                        </div>
                    </div>
                    
                    <div class="receive-network-content" id="receive-ETH">
                        <div class="text-center">
                            <div id="qrCodeETH" class="mb-4" style="display: flex; justify-content: center;"></div>
                            <div class="form-group">
                                <label class="form-label">Tu direccion ETH</label>
                                <div class="flex items-center">
                                    <input type="text" id="receiveAddressETH" class="form-control" readonly>
                                    <button class="btn btn-secondary copy-address-btn" data-network="ETH" style="margin-left: 0.5rem;">
                                        <i class="fas fa-copy"></i>
                                    </button>
                                </div>
                            </div>
                            <p style="color: var(--text-gray); font-size: 0.875rem; margin-top: 1rem;">
                                Comparte esta direccion para recibir ETH o USDT en Ethereum Mainnet
                            </p>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button id="closeReceiveBtn" class="btn btn-secondary">Cerrar</button>
            </div>
        </div>
    </div>

    <div id="backupModal" class="modal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-header">
                <h3 class="modal-title">Backup Multi-Red</h3>
            </div>
            <div class="modal-body">
                <div class="multichain-backup-container">
                    <div class="backup-network-tabs" id="backupNetworkTabs"></div>
                    
                    <div class="backup-content" id="backupContent"></div>
                    
                    <div class="backup-actions mt-6">
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-2">
                            <button id="downloadIndividualBackupBtn" class="btn btn-secondary">
                                <i class="fas fa-download"></i> Exportar Red Actual
                            </button>
                            <button id="downloadCompleteBackupBtn" class="btn btn-primary">
                                <i class="fas fa-file-archive"></i> Exportar Todo (ZIP)
                            </button>
                        </div>
                    </div>
                    
                    <div class="security-warning mt-4">
                        <i class="fas fa-exclamation-triangle"></i>
                        <p>Guarda esta informacion en un lugar seguro. Cualquiera con acceso a estos datos puede controlar tus fondos.</p>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button id="closeBackupBtn" class="btn btn-secondary">Cerrar</button>
            </div>
        </div>
    </div>
<div id="earnModal" class="modal">
    <div class="modal-content" style="max-width: 700px;">
        <div class="modal-header">
            <h3 class="modal-title">🚀 Earn Flexible - Generar Rendimientos</h3>
            <button class="btn btn-sm btn-secondary" onclick="refreshAllApy()">
                <i class="fas fa-sync-alt"></i>
            </button>
        </div>
        <div class="modal-body">
            
<div class="earn-network-tabs mb-4">
    <div class="flex gap-2 mb-4">
        <button class="btn earn-tab-btn active" data-network="BSC" onclick="switchEarnTab('BSC')">
            <i class="fab fa-bootstrap"></i> BSC - Venus
        </button>
        <button class="btn earn-tab-btn" data-network="ETH" onclick="switchEarnTab('ETH')">
            <i class="fab fa-ethereum"></i> ETH - Aave V3
        </button>
        <button class="btn earn-tab-btn" data-network="COMPOUND" onclick="switchEarnTab('COMPOUND')">
            <i class="fas fa-cubes"></i> Compound V3
        </button>
    </div>
</div>
            
            <!-- Contenido BSC Venus -->
            <div id="earnBSC" class="earn-content active">
                <div class="card p-4 mb-4 bg-gradient-to-r from-yellow-500/10 to-orange-500/10">
                    <div class="flex justify-between items-center mb-3">
                        <h4 class="text-gold font-bold">💰 Venus Protocol - BSC</h4>
                        <div class="flex items-center gap-2">
                            <span class="network-badge bsc">BSC</span>
                            <span class="text-xs bg-green-500/20 text-green-400 px-2 py-1 rounded" id="venusLastUpdate">
                                Actualizando...
                            </span>
                        </div>
                    </div>
                    
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-4">
                        <div class="text-center p-3 bg-black/20 rounded-lg">
                            <p class="text-sm text-gray-400 mb-1">APY USDT</p>
                            <p class="text-xl font-bold text-green-400" id="venusUsdtApy">-</p>
                            <p class="text-xs text-gray-400 mt-1" id="venusApyStatus">🔄 Calculando...</p>
                        </div>
                        <div class="text-center p-3 bg-black/20 rounded-lg">
                            <p class="text-sm text-gray-400 mb-1">Tu Balance</p>
                            <p class="text-xl font-bold" id="venusUsdtBalance">0 USDT</p>
                            <p class="text-xs text-gray-400 mt-1">En Venus</p>
                        </div>
                        <div class="text-center p-3 bg-black/20 rounded-lg">
                            <p class="text-sm text-gray-400 mb-1">Disponible</p>
                            <p class="text-xl font-bold" id="venusAvailableUsdt">0 USDT</p>
                            <p class="text-xs text-gray-400 mt-1">En tu Wallet</p>
                        </div>
                        <div class="text-center p-3 bg-black/20 rounded-lg">
                            <p class="text-sm text-gray-400 mb-1">Rendimientos</p>
                            <p class="text-xl font-bold text-green-400" id="venusEarnings">$0.00</p>
                            <p class="text-xs text-gray-400 mt-1">Acumulados</p>
                        </div>
                    </div>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Cantidad a Depositar (USDT)</label>
                    <div class="flex gap-2 mb-2">
                        <input type="number" id="venusDepositAmount" class="form-control flex-1" placeholder="0.0" step="0.1">
                        <button class="btn btn-secondary" onclick="setMaxEarnAmount('venus')">Max</button>
                    </div>
                    <div class="flex justify-between text-sm text-gray-400">
                        <span>Balance: <span id="venusWalletBalance">0 USDT</span></span>
                        <span id="venusDepositValue">$0.00</span>
                    </div>
                </div>
                
                <div class="flex gap-2 mt-4">
                    <button class="btn btn-primary flex-1" onclick="depositToVenus()" id="venusDepositBtn">
                        <i class="fas fa-coins"></i>
                        <span>Depositar</span>
                        <span class="loading hidden" id="venusDepositLoading"></span>
                    </button>
                    <button class="btn btn-warning flex-1" onclick="withdrawFromVenus()" id="venusWithdrawBtn">
                        <i class="fas fa-hand-holding-usd"></i>
                        <span>Retirar Todo</span>
                        <span class="loading hidden" id="venusWithdrawLoading"></span>
                    </button>
                </div>
            </div>
            
            <!-- Contenido ETH Aave -->
            <div id="earnETH" class="earn-content">
                <div class="card p-4 mb-4 bg-gradient-to-r from-blue-500/10 to-purple-500/10">
                    <div class="flex justify-between items-center mb-3">
                        <h4 class="text-gold font-bold">🏦 Aave V3 - Ethereum</h4>
                        <div class="flex items-center gap-2">
                            <span class="network-badge eth">ETH</span>
                            <span class="text-xs bg-green-500/20 text-green-400 px-2 py-1 rounded" id="aaveLastUpdate">
                                Actualizando...
                            </span>
                        </div>
                    </div>
                    
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-4">
                        <div class="text-center p-3 bg-black/20 rounded-lg">
                            <p class="text-sm text-gray-400 mb-1">APY USDT</p>
                            <p class="text-xl font-bold text-green-400" id="aaveUsdtApy">-</p>
                            <p class="text-xs text-gray-400 mt-1" id="aaveApyStatus">🔄 Calculando...</p>
                        </div>
                        <div class="text-center p-3 bg-black/20 rounded-lg">
                            <p class="text-sm text-gray-400 mb-1">Tu Balance</p>
                            <p class="text-xl font-bold" id="aaveUsdtBalance">0 USDT</p>
                            <p class="text-xs text-gray-400 mt-1">En Aave</p>
                        </div>
                        <div class="text-center p-3 bg-black/20 rounded-lg">
                            <p class="text-sm text-gray-400 mb-1">Disponible</p>
                            <p class="text-xl font-bold" id="aaveAvailableUsdt">0 USDT</p>
                            <p class="text-xs text-gray-400 mt-1">En tu Wallet</p>
                        </div>
                        <div class="text-center p-3 bg-black/20 rounded-lg">
                            <p class="text-sm text-gray-400 mb-1">Rendimientos</p>
                            <p class="text-xl font-bold text-green-400" id="aaveEarnings">$0.00</p>
                            <p class="text-xs text-gray-400 mt-1">Acumulados</p>
                        </div>
                    </div>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Cantidad a Depositar (USDT)</label>
                    <div class="flex gap-2 mb-2">
                        <input type="number" id="aaveDepositAmount" class="form-control flex-1" placeholder="0.0" step="0.1">
                        <button class="btn btn-secondary" onclick="setMaxEarnAmount('aave')">Max</button>
                    </div>
                    <div class="flex justify-between text-sm text-gray-400">
                        <span>Balance: <span id="aaveWalletBalance">0 USDT</span></span>
                        <span id="aaveDepositValue">$0.00</span>
                    </div>
                </div>
                
                <div class="flex gap-2 mt-4">
                    <button class="btn btn-primary flex-1" onclick="depositToAave()" id="aaveDepositBtn">
                        <i class="fas fa-coins"></i>
                        <span>Depositar</span>
                        <span class="loading hidden" id="aaveDepositLoading"></span>
                    </button>
                    <button class="btn btn-warning flex-1" onclick="withdrawFromAave()" id="aaveWithdrawBtn">
                        <i class="fas fa-hand-holding-usd"></i>
                        <span>Retirar Todo</span>
                        <span class="loading hidden" id="aaveWithdrawLoading"></span>
                    </button>
                </div>
                
                <!-- Información adicional de Aave -->
                <div class="mt-4 p-3 bg-blue-500/10 rounded-lg border border-blue-500/20">
                    <div class="flex items-center gap-2 mb-2">
                        <i class="fas fa-info-circle text-blue-400"></i>
                        <span class="text-sm font-semibold text-blue-400">Información Aave V3</span>
                    </div>
                    <p class="text-xs text-gray-400">
                        • Tasas variables en tiempo real • Sin penalizaciones por retiro • Garantía descentralizada
                    </p>
                </div>
            </div>
        </div>
        

<div id="earnCOMPOUND" class="earn-content">
    <div class="card p-4 mb-4 bg-gradient-to-r from-purple-500/10 to-pink-500/10">
        <div class="flex justify-between items-center mb-3">
            <h4 class="text-gold font-bold">⚡ Compound V3 - Producción Real</h4>
            <div class="flex items-center gap-2">
                <span class="network-badge eth" id="compoundNetworkBadge">ETH</span>
                <span class="text-xs bg-green-500/20 text-green-400 px-2 py-1 rounded" id="compoundLastUpdate">
                    Conectando...
                </span>
            </div>
        </div>
        
        <!-- Selector de Red -->
        <div class="network-buttons mb-4">
            <button class="network-btn active" data-network="ETH" onclick="switchCompoundNetwork('ETH')">
                <i class="fab fa-ethereum"></i> Ethereum Mainnet
            </button>
            <button class="network-btn" data-network="BASE" onclick="switchCompoundNetwork('BASE')">
                <i class="fas fa-layer-group"></i> Base Mainnet
            </button>
        </div>
        
        <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-4">
            <div class="text-center p-3 bg-black/20 rounded-lg">
                <p class="text-sm text-gray-400 mb-1">APY USDC</p>
                <p class="text-xl font-bold text-green-400" id="compoundUsdcApy">-</p>
                <p class="text-xs text-gray-400 mt-1" id="compoundApyStatus">🔄 Blockchain</p>
            </div>
            <div class="text-center p-3 bg-black/20 rounded-lg">
                <p class="text-sm text-gray-400 mb-1">Tu Balance</p>
                <p class="text-xl font-bold" id="compoundUsdcBalance">0 USDC</p>
                <p class="text-xs text-gray-400 mt-1">En Compound V3</p>
            </div>
            <div class="text-center p-3 bg-black/20 rounded-lg">
                <p class="text-sm text-gray-400 mb-1">Disponible</p>
                <p class="text-xl font-bold" id="compoundAvailableUsdc">0 USDC</p>
                <p class="text-xs text-gray-400 mt-1">En tu Wallet</p>
            </div>
            <div class="text-center p-3 bg-black/20 rounded-lg">
                <p class="text-sm text-gray-400 mb-1">Rendimientos</p>
                <p class="text-xl font-bold text-green-400" id="compoundEarnings">$0.00</p>
                <p class="text-xs text-gray-400 mt-1">Diarios estimados</p>
            </div>
        </div>

        <!-- Información de la Red -->
        <div class="bg-blue-500/10 border border-blue-500/20 rounded-lg p-3 mb-4">
            <div class="flex items-center gap-2">
                <i class="fas fa-network-wired text-blue-400"></i>
                <span class="text-sm font-semibold text-blue-400" id="compoundNetworkInfo">
                    Ethereum Mainnet - Contrato Real
                </span>
            </div>
        </div>
    </div>
    
    <div class="form-group">
        <label class="form-label">Cantidad a Depositar (USDC)</label>
        <div class="flex gap-2 mb-2">
            <input type="number" id="compoundDepositAmount" class="form-control flex-1" placeholder="0.0" step="0.1" min="0">
            <button class="btn btn-secondary" onclick="setMaxEarnAmount('compound')">Max</button>
        </div>
        <div class="flex justify-between text-sm text-gray-400">
            <span>Balance: <span id="compoundWalletBalance">0 USDC</span></span>
            <span id="compoundDepositValue">$0.00</span>
        </div>
    </div>
    
    <div class="flex gap-2 mt-4">
        <button class="btn btn-primary flex-1" onclick="depositToCompound()" id="compoundDepositBtn">
            <i class="fas fa-coins"></i>
            <span>Depositar USDC</span>
            <span class="loading hidden" id="compoundDepositLoading"></span>
        </button>
        <button class="btn btn-warning flex-1" onclick="withdrawFromCompound()" id="compoundWithdrawBtn">
            <i class="fas fa-hand-holding-usd"></i>
            <span>Retirar Todo</span>
            <span class="loading hidden" id="compoundWithdrawLoading"></span>
        </button>
    </div>
    
    <!-- Información de Transacciones -->
    <div class="mt-4 p-3 bg-gray-500/10 rounded-lg border border-gray-500/20">
        <div class="flex items-center gap-2 mb-2">
            <i class="fas fa-info-circle text-gray-400"></i>
            <span class="text-sm font-semibold text-gray-400">Información de Transacciones</span>
        </div>
        <p class="text-xs text-gray-400">
            • Gas Fee: 1 Gwei • Tiempo estimado: 15-30 segundos • Red: <span id="compoundTxNetwork">Ethereum</span>
        </p>
    </div>
</div>
        <div class="modal-footer">
            <button class="btn btn-secondary" onclick="hideModal('earnModal')">Cerrar</button>
        </div>
    </div>
</div>
    <div id="importWalletModal" class="modal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <h3 class="modal-title">Importar Wallet Multi-Red</h3>
            </div>
            <div class="modal-body">
                <div class="multichain-import-container">
                    <div class="import-method-tabs">
                        <button class="import-tab-btn active" data-method="individual">
                            <i class="fas fa-key"></i> Individual
                        </button>
                        <button class="import-tab-btn" data-method="file">
                            <i class="fas fa-file-import"></i> Archivo
                        </button>
                        <button class="import-tab-btn" data-method="massive">
                            <i class="fas fa-layer-group"></i> Masiva
                        </button>
                    </div>
                    
                    <div class="import-content">
                        <div id="individualImport" class="import-method-content active">
                            <div class="network-selection">
                                <label class="form-label">Seleccionar Red</label>
                                <div class="network-buttons">
                                    <button class="network-btn active" data-network="BSC">BSC</button>
                                    <button class="network-btn" data-network="ETH">ETH</button>
                                </div>
                            </div>
                            
                            <div class="import-type-selection">
                                <label class="form-label">Metodo de Importacion</label>
                                <div class="import-type-buttons">
                                    <button class="import-type-btn active" data-type="mnemonic">
                                        <i class="fas fa-seedling"></i> Frase (12 palabras)
                                    </button>
                                    <button class="import-type-btn" data-type="privateKey">
                                        <i class="fas fa-key"></i> Clave Privada
                                    </button>
                                </div>
                            </div>
                            
                            <div class="form-group">
                                <label id="importInputLabel" class="form-label">Frase de Recuperacion</label>
                                <textarea id="importInput" class="form-control" 
                                          placeholder="Ingresa tus 12 palabras separadas por espacios"
                                          rows="3"></textarea>
                            </div>
                            
                            <div class="import-actions">
                                <button id="validateImportBtn" class="btn btn-secondary">
                                    <i class="fas fa-check"></i> Validar
                                </button>
                                <button id="confirmIndividualImportBtn" class="btn btn-primary">
                                    <i class="fas fa-download"></i> Importar Red
                                </button>
                            </div>
                        </div>
                        
                        <div id="fileImport" class="import-method-content">
                            <div class="form-group">
                                <label class="form-label">Seleccionar Archivo de Backup</label>
                                <div class="file-drop-zone" id="fileDropZone">
                                    <i class="fas fa-cloud-upload-alt" style="font-size: 2rem; margin-bottom: 1rem; color: var(--primary-gold);"></i>
                                    <p style="font-weight: 500; margin-bottom: 0.5rem;">Arrastra tu archivo aqui o haz clic para seleccionar</p>
                                    <p style="color: var(--text-gray); font-size: 0.875rem;">Soporta archivos JSON de backup individuales o completos</p>
                                    <input type="file" id="fileInput" accept=".json" style="display: none;">
                                </div>
                            </div>
                            
                            <div class="file-info" id="fileInfo">
                                <p class="text-gray-400">No se ha seleccionado ningun archivo</p>
                            </div>
                            
                            <div class="import-actions">
                                <button id="confirmFileImportBtn" class="btn btn-primary" disabled>
                                    <i class="fas fa-file-import"></i> Importar Archivo
                                </button>
                            </div>
                        </div>
                        
                        <div id="massiveImport" class="import-method-content">
                            <div class="form-group">
                                <label class="form-label">Datos de Importacion Masiva</label>
                                <textarea id="massiveImportInput" class="form-control" 
                                          placeholder='Pega aqui el JSON con multiples wallets. Formato: 
[
  {
    "network": "BSC",
    "privateKey": "0x...",
    "mnemonic": "palabra1 palabra2 ..."
  },
  ...
]'
                                          rows="6"></textarea>
                            </div>
                            
                            <div class="security-warning">
                                <i class="fas fa-exclamation-triangle"></i>
                                <p>Esta funcion es para usuarios avanzados. Asegurate de que los datos sean correctos y provengan de una fuente confiable.</p>
                            </div>
                            
                            <div class="import-actions">
                                <button id="validateMassiveBtn" class="btn btn-secondary">
                                    <i class="fas fa-check"></i> Validar JSON
                                </button>
                                <button id="confirmMassiveImportBtn" class="btn btn-primary" disabled>
                                    <i class="fas fa-layer-group"></i> Importar Masivo
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button id="cancelImportBtn" class="btn btn-secondary">Cancelar</button>
            </div>
        </div>
    </div>

    <div id="transactionDetailsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Detalles de Transaccion</h3>
            </div>
            <div class="modal-body">
                <div id="transactionDetailsContent"></div>
            </div>
            <div class="modal-footer">
                <button id="closeTransactionDetailsBtn" class="btn btn-secondary">Cerrar</button>
            </div>
        </div>
    </div>

<script>
const MULTICHAIN_CONFIG = {
    BSC: {
        RPC_URL: 'https://bsc-dataseed.binance.org/',
        CHAIN_ID: 56,
        EXPLORER_API: 'https://api.etherscan.io/v2/api?chainid=56&',
        API_KEY: 'J646TDGCJBBRCIWJTRNAUW7DXSK2QAD1XD',
        TOKENS: {
            NATIVE: 'BNB',
            USDT: {
                CONTRACT: '0x55d398326f99059fF775485246999027B3197955',
                SYMBOL: 'USDT',
                DECIMALS: 18
            }
        },
        GAS_API: 'https://api.bscscan.com/api?module=gastracker&action=gasoracle',
        DERIVATION_PATH: "m/44'/60'/0'/0/0"
    },
    ETH: {
        RPC_URL: 'https://ethereum.publicnode.com',
        CHAIN_ID: 1,
        EXPLORER_API: 'https://api.etherscan.io/v2/api?chainid=1&',
        API_KEY: 'M1IYKPBBI37HTK9VYBICN3HSFCQ73R6P3E',
        TOKENS: {
            NATIVE: 'ETH',
            USDT: {
                CONTRACT: '0xdAC17F958D2ee523a2206206994597C13D831ec7',
                SYMBOL: 'USDT',
                DECIMALS: 6
            }
        },
        GAS_API: 'https://api.etherscan.io/api?module=gastracker&action=gasoracle',
        DERIVATION_PATH: "m/44'/60'/0'/0/0"
    },
    PRICE_APIS: {
        BNB: 'https://api.coingecko.com/api/v3/simple/price?ids=binancecoin&vs_currencies=usd',
        ETH: 'https://api.coingecko.com/api/v3/simple/price?ids=ethereum&vs_currencies=usd',
        USDT: 'https://api.coingecko.com/api/v3/simple/price?ids=tether&vs_currencies=usd'
    },
    STORAGE_KEYS: {
        WALLETS: 'multichain_wallets_v5',
        CACHE: 'multichain_cache_v5',
        APP_STATE: 'multichain_app_state_v5',
        SETTINGS: 'multichain_settings_v5'
    },
    CACHE_DURATION: {
        BALANCES: 30000,
        TRANSACTIONS: 60000,
        PRICES: 30000,
        GAS: 60000
    },
    UPDATE_INTERVALS: {
        PRICES: 30000,
        BALANCES: 45000,
        SYNC: 120000
    }
};

const USDT_ABI = [
    {
        "constant": true,
        "inputs": [{"name": "_owner", "type": "address"}],
        "name": "balanceOf",
        "outputs": [{"name": "balance", "type": "uint256"}],
        "type": "function"
    },
    {
        "constant": false,
        "inputs": [
            {"name": "_to", "type": "address"},
            {"name": "_value", "type": "uint256"}
        ],
        "name": "transfer",
        "outputs": [{"name": "", "type": "bool"}],
        "type": "function"
    },
    {
        "constant": false,
        "inputs": [
            {"name": "_spender", "type": "address"},
            {"name": "_value", "type": "uint256"}
        ],
        "name": "approve",
        "outputs": [{"name": "", "type": "bool"}],
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [
            {"name": "_owner", "type": "address"},
            {"name": "_spender", "type": "address"}
        ],
        "name": "allowance",
        "outputs": [{"name": "", "type": "uint256"}],
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [],
        "name": "decimals",
        "outputs": [{"name": "", "type": "uint8"}],
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [],
        "name": "symbol",
        "outputs": [{"name": "", "type": "string"}],
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [],
        "name": "name",
        "outputs": [{"name": "", "type": "string"}],
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [],
        "name": "totalSupply",
        "outputs": [{"name": "", "type": "uint256"}],
        "type": "function"
    }
];
// AGREGAR esto al inicio del código, después de MULTICHAIN_CONFIG
const DEFI_CONFIG = {
    VENUS_BSC: {
        COMPTROLLER: '0xfD36E2c2a6789Db23113685031d7F16329158384',
        VUSDT: '0xfD5840Cd36d94D7229439859C0112a4185BC0255',
        VBNB: '0xA07c5b74C9B40447a954e1466938b865b6BBea36',
        LENS: '0xfD36E2c2a6789Db23113685031d7F16329158384',
        GAS_PRICE: "1"
    },
    AAVE_ETH: {
        POOL: '0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2',
        AUSDT: '0x23878914EFE38d27C4D67Ab83ed1b93A74D4086a',
        POOL_DATA_PROVIDER: '0x7B4EB56E7CD4b454BA8ff71E4518EfE3d6d1e99A',
        UI_POOL_DATA_PROVIDER: '0x548e95Ce38B43433d2f4D0b6Ee4E0e5A746Ea8E5',
        GAS_PRICE: "1"
    }
};

// ABI para Venus Protocol
const VENUS_ABI = [
    "function mint(uint mintAmount) returns (uint)",
    "function redeem(uint redeemTokens) returns (uint)", 
    "function balanceOf(address owner) view returns (uint)",
    "function exchangeRateCurrent() view returns (uint)"
];


// CONFIGURACIÓN REAL PARA PRODUCCIÓN - Compound V3
const COMPOUND_V3_CONFIG = {
    ETH: {
        COMPTROLLER: '0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2',
        COMET: '0xc3d688B66703497DAA19211EEdff47f25384cdc3', // Comet USDC
        USDC: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',
        BASE_TOKEN: 'USDC',
        GAS_PRICE: "1",
        CHAIN_ID: 1,
        RPC_URL: 'https://ethereum.publicnode.com'
    },
    BASE: {
        COMPTROLLER: '0x46e6b214b524310239732D51387075E0e70970bf',
        COMET: '0x46e6b214b524310239732D51387075E0e70970bf', // Base Comet
        USDC: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',
        BASE_TOKEN: 'USDC',
        GAS_PRICE: "1",
        CHAIN_ID: 8453,
        RPC_URL: 'https://base.publicnode.com'
    }
};


const AAVE_DATA_PROVIDER_ABI = [
    "function getReserveData(address asset) external view returns (uint256 availableLiquidity, uint256 totalStableDebt, uint256 totalVariableDebt, uint256 liquidityRate, uint256 variableBorrowRate, uint256 stableBorrowRate, uint256 averageStableBorrowRate, uint256 liquidityIndex, uint256 variableBorrowIndex, uint40 lastUpdateTimestamp)",
    "function getUserReserveData(address asset, address user) external view returns (uint256 currentATokenBalance, uint256 currentStableDebt, uint256 currentVariableDebt, uint256 principalStableDebt, uint256 scaledVariableDebt, uint256 stableBorrowRate, uint256 liquidityRate, uint40 stableRateLastUpdated, bool usageAsCollateralEnabled)"
];

let appState = {
    wallets: {
        BSC: null,
        ETH: null,
    },
    providers: {
        BSC: null,
        ETH: null,
        BASE: new ethers.providers.JsonRpcProvider(COMPOUND_V3_CONFIG.BASE.RPC_URL)
    },
    prices: {
        BNB: 0,
        ETH: 0,
        USDT: 1
    },
    cache: {
        balances: {
            BSC: { data: null, timestamp: 0 },
            ETH: { data: null, timestamp: 0 },
        },
        transactions: {
            BSC: { data: null, timestamp: 0 },
            ETH: { data: null, timestamp: 0 },
        },
        prices: { data: null, timestamp: 0 },
        gas: {
            BSC: { data: null, timestamp: 0 },
            ETH: { data: null, timestamp: 0 },
        }
    },
    connectionStatus: {
        BSC: false,
        ETH: false,
        online: true
    },
    gasPrices: {
        BSC: { low: 1, medium: 3, high: 5, veryHigh: 7 },
        ETH: { low: 1, medium: 3, high: 5, veryHigh: 7 },
    },
    selectedGasOption: 'low',
    transactionState: {
    allTransactions: [],
    filteredTransactions: [],
    currentFilter: 'all',
    networkFilter: 'all',
    currentPage: 1,
    itemsPerPage: 10,
    totalPages: 1
},
// AGREGAR esto al appState, después de transactionState
defi: {
    venus: { 
        usdtBalance: '0', 
        apy: '0',
        lastUpdate: 0,
        earnings: '0'
    },
    aave: { 
        usdtBalance: '0', 
        apy: '0',
        lastUpdate: 0,
        earnings: '0'
    },
    compound: {
        usdcBalance: '0',
        apy: '0',
        lastUpdate: 0,
        earnings: '0',
        network: 'ETH'
    },
    apyCache: {
        venus: { data: null, timestamp: 0 },
        aave: { data: null, timestamp: 0 },
        compound: { data: null, timestamp: 0 }
    }
},
};

async function initializeMultiChainApp() {
    console.log('Inicializando Wallet Multi-Red...');
    try {
        await setupMultiChainProviders();
        setupMultiChainEventListeners();
        initializeMultiChainUI();
        const stateLoaded = await loadMultiChainAppState();
        const walletsLoaded = checkExistingMultiChainWallets();
        appState.connectionStatus.online = navigator.onLine;
        if (walletsLoaded) {
            await loadAllGasPrices();
            if (appState.connectionStatus.online) {
                await loadInitialMultiChainData();
            } else {
                await loadOfflineMultiChainData();
            }
        }
        if (appState.connectionStatus.online) {
            setupMultiChainAutoUpdates();
        }
        console.log('Aplicacion inicializada');
    } catch (error) {
        console.error('Error inicializando aplicacion:', error);
        showToast('Error al inicializar: ' + error.message, 'error');
    }
}

async function setupMultiChainProviders() {
    console.log('Configurando proveedores...');
    try {
        appState.providers.BSC = new ethers.providers.JsonRpcProvider(MULTICHAIN_CONFIG.BSC.RPC_URL);
        appState.providers.ETH = new ethers.providers.JsonRpcProvider(MULTICHAIN_CONFIG.ETH.RPC_URL);
        console.log('Proveedores configurados');
    } catch (error) {
        console.error('Error configurando proveedores:', error);
        throw error;
    }
}

function setupMultiChainEventListeners() {
    document.getElementById('createWalletBtn').addEventListener('click', createMultiChainWallets);
    document.getElementById('importWalletBtn').addEventListener('click', showMultiChainImportModal);
    document.getElementById('connectWalletBtn').addEventListener('click', connectMultiChainWallets);
    document.getElementById('sendBtn').addEventListener('click', showMultiChainSendModal);
    document.getElementById('receiveBtn').addEventListener('click', showMultiChainReceiveModal);
    document.getElementById('backupBtn').addEventListener('click', showMultiChainBackupModal);
    document.getElementById('disconnectBtn').addEventListener('click', disconnectMultiChainWallets);
    document.getElementById('refreshHistoryBtn').addEventListener('click', loadMultiChainTransactionHistory);
    document.getElementById('sendNetworkSelect').addEventListener('change', handleNetworkChange);
    document.getElementById('sendTokenSelect').addEventListener('change', handleTokenChange);
    document.getElementById('sendToAddress').addEventListener('input', validateSendAddress);
    document.getElementById('sendAmount').addEventListener('input', updateSendEstimates);
    document.getElementById('sendMaxBtn').addEventListener('click', setMaxAmount);
    document.getElementById('cancelSendBtn').addEventListener('click', hideSendModal);
    document.getElementById('confirmSendBtn').addEventListener('click', confirmMultiChainSend);
    document.getElementById('closeReceiveBtn').addEventListener('click', hideReceiveModal);
    document.getElementById('closeBackupBtn').addEventListener('click', hideBackupModal);
    document.getElementById('downloadIndividualBackupBtn').addEventListener('click', downloadIndividualBackup);
    document.getElementById('downloadCompleteBackupBtn').addEventListener('click', downloadCompleteBackup);
    document.getElementById('cancelImportBtn').addEventListener('click', hideImportModal);
    document.getElementById('validateImportBtn').addEventListener('click', validateIndividualImport);
    document.getElementById('confirmIndividualImportBtn').addEventListener('click', confirmIndividualImport);
    document.getElementById('validateMassiveBtn').addEventListener('click', validateMassiveImport);
    document.getElementById('confirmMassiveImportBtn').addEventListener('click', confirmMassiveImport);
    document.getElementById('closeTransactionDetailsBtn').addEventListener('click', () => hideModal('transactionDetailsModal'));
    initializeSimpleTransactionSystem();
    setupPagination();
    window.addEventListener('online', handleOnlineStatus);
    window.addEventListener('offline', handleOfflineStatus);
    setInterval(saveMultiChainAppState, 30000);
    window.addEventListener('beforeunload', saveMultiChainAppState);
}

// ===== SISTEMA SIMPLIFICADO - AGREGAR ESTO =====
function initializeSimpleTransactionSystem() {
    console.log('🔄 Inicializando sistema de transacciones simplificado...');
    
    appState.transactionState = {
        allTransactions: [],
        filteredTransactions: [],
        currentFilter: 'all',
        networkFilter: 'all',
        currentPage: 1,
        itemsPerPage: 10,
        totalPages: 1
    };
    
    initializeSimpleFilters();
}

function initializeSimpleFilters() {
    // Filtros por tipo
    const typeButtons = document.querySelectorAll('.filter-btn[data-type]');
    typeButtons.forEach(btn => {
        btn.addEventListener('click', function() {
            typeButtons.forEach(b => b.classList.remove('active'));
            this.classList.add('active');
            appState.transactionState.currentFilter = this.getAttribute('data-type');
            appState.transactionState.currentPage = 1;
            applySimpleFilters();
        });
    });
    
    // Filtros por red
    const networkButtons = document.querySelectorAll('.filter-btn[data-network]');
    networkButtons.forEach(btn => {
        btn.addEventListener('click', function() {
            networkButtons.forEach(b => b.classList.remove('active'));
            this.classList.add('active');
            appState.transactionState.networkFilter = this.getAttribute('data-network');
            appState.transactionState.currentPage = 1;
            applySimpleFilters();
        });
    });
}

function applySimpleFilters() {
    let filtered = [...appState.transactionState.allTransactions];
    
    // Filtro por estado
    if (appState.transactionState.currentFilter !== 'all') {
        switch (appState.transactionState.currentFilter) {
            case 'received': filtered = filtered.filter(tx => tx.isIncoming === true); break;
            case 'sent': filtered = filtered.filter(tx => tx.isIncoming === false); break;
            case 'confirmed': filtered = filtered.filter(tx => tx.status === 'confirmed'); break;
            case 'pending': filtered = filtered.filter(tx => tx.status === 'pending'); break;
            case 'failed': filtered = filtered.filter(tx => tx.status === 'failed'); break;
        }
    }
    
    // Filtro por red
    if (appState.transactionState.networkFilter !== 'all') {
        filtered = filtered.filter(tx => tx.network === appState.transactionState.networkFilter);
    }
    
    // Ordenar
    filtered.sort((a, b) => {
        const timeA = parseInt(a.timeStamp) || 0;
        const timeB = parseInt(b.timeStamp) || 0;
        return timeB - timeA;
    });
    
    appState.transactionState.filteredTransactions = filtered;
    appState.transactionState.totalPages = Math.ceil(filtered.length / appState.transactionState.itemsPerPage);
    
    displayCurrentPage();
    updateTransactionCount();
    updateSimpleFilterCounts();
}

// REEMPLAZAR la función updateFilterCounts con esta versión corregida
function updateFilterCounts() {
    const totalTransactions = appState.transactionState.allTransactions.length;
    const filteredTransactions = appState.transactionState.filteredTransactions.length;
    
    // Actualizar contador principal
    const filteredCount = document.getElementById('filteredCount');
    if (filteredCount) filteredCount.textContent = filteredTransactions;
    
    // Actualizar badges de filtro (versión simplificada)
    updateSimpleFilterCounts();
}

// REEMPLAZAR updateSimpleFilterCounts si existe
function updateSimpleFilterCounts() {
    const allTransactions = appState.transactionState.allTransactions;
    
    // Actualizar badges de tipo
    document.querySelectorAll('.filter-btn[data-type]').forEach(btn => {
        const filterType = btn.getAttribute('data-type');
        let count = 0;
        
        switch (filterType) {
            case 'all': count = allTransactions.length; break;
            case 'received': count = allTransactions.filter(tx => tx.isIncoming === true).length; break;
            case 'sent': count = allTransactions.filter(tx => tx.isIncoming === false).length; break;
            case 'confirmed': count = allTransactions.filter(tx => tx.status === 'confirmed').length; break;
            case 'pending': count = allTransactions.filter(tx => tx.status === 'pending').length; break;
            case 'failed': count = allTransactions.filter(tx => tx.status === 'failed').length; break;
        }
        
        const badge = btn.querySelector('.filter-badge');
        if (badge) {
            badge.textContent = count;
            badge.style.opacity = count === 0 ? '0.5' : '1';
        }
    });
    
    // Actualizar badges de red
    document.querySelectorAll('.filter-btn[data-network]').forEach(btn => {
        const network = btn.getAttribute('data-network');
        let count = 0;
        
        switch (network) {
            case 'all': count = allTransactions.length; break;
            case 'BSC': count = allTransactions.filter(tx => tx.network === 'BSC').length; break;
            case 'ETH': count = allTransactions.filter(tx => tx.network === 'ETH').length; break;
        }
        
        const badge = btn.querySelector('.filter-badge');
        if (badge) {
            badge.textContent = count;
            badge.style.opacity = count === 0 ? '0.5' : '1';
        }
    });
}
function setupPagination() {
    document.getElementById('prevPageBtn').addEventListener('click', goToPreviousPage);
    document.getElementById('nextPageBtn').addEventListener('click', goToNextPage);
}

async function handleNetworkChange() {
    await updateTokenOptions();
    resetSendForm();
    await updateGasOptionsForNetwork(this.value);
    updateSendEstimates();
}

function handleTokenChange() {
    updateBalanceForSend();
    updateSendEstimates();
}

function resetSendForm() {
    document.getElementById('sendToAddress').value = '';
    document.getElementById('sendAmount').value = '';
    document.getElementById('addressValidation').classList.add('hidden');
    document.getElementById('sendMaxAmount').textContent = '0.0';
    updateSendEstimates();
}

function initializeMultiChainUI() {
    initializeImportModal();
    updateConnectionStatus();
}

function initializeImportModal() {
    document.querySelectorAll('.import-tab-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            document.querySelectorAll('.import-tab-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.import-method-content').forEach(c => c.classList.remove('active'));
            this.classList.add('active');
            const method = this.getAttribute('data-method');
            document.getElementById(method + 'Import').classList.add('active');
            resetImportForms();
        });
    });
    
    document.querySelectorAll('.network-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            document.querySelectorAll('.network-btn').forEach(b => b.classList.remove('active'));
            this.classList.add('active');
        });
    });
    
    document.querySelectorAll('.import-type-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            document.querySelectorAll('.import-type-btn').forEach(b => b.classList.remove('active'));
            this.classList.add('active');
            const type = this.getAttribute('data-type');
            const label = document.getElementById('importInputLabel');
            const input = document.getElementById('importInput');
            if (type === 'mnemonic') {
                label.textContent = 'Frase de Recuperacion (12 palabras)';
                input.placeholder = 'Ingresa tus 12 palabras separadas por espacios';
                input.rows = 3;
            } else {
                label.textContent = 'Clave Privada';
                input.placeholder = 'Ingresa tu clave privada (0x...)';
                input.rows = 2;
            }
        });
    });
    
    setupFileDropZone();
}

function setupFileDropZone() {
    const dropZone = document.getElementById('fileDropZone');
    const fileInput = document.getElementById('fileInput');
    if (!dropZone) return;
    
    dropZone.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', handleFileSelect);
    
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        dropZone.addEventListener(eventName, preventDefaults, false);
    });
    
    function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
    }
    
    ['dragenter', 'dragover'].forEach(eventName => {
        dropZone.addEventListener(eventName, highlight, false);
    });
    
    ['dragleave', 'drop'].forEach(eventName => {
        dropZone.addEventListener(eventName, unhighlight, false);
    });
    
    function highlight() {
        dropZone.classList.add('dragover');
    }
    
    function unhighlight() {
        dropZone.classList.remove('dragover');
    }
    
    dropZone.addEventListener('drop', handleDrop, false);
    
    function handleDrop(e) {
        const dt = e.dataTransfer;
        const files = dt.files;
        handleFiles(files);
    }
}

function handleFileSelect(e) {
    const files = e.target.files;
    handleFiles(files);
}

function handleFiles(files) {
    if (files.length === 0) return;
    const file = files[0];
    const fileInfo = document.getElementById('fileInfo');
    const confirmFileImportBtn = document.getElementById('confirmFileImportBtn');
    
    if (!file.name.endsWith('.json')) {
        showToast('Solo se permiten archivos JSON', 'error');
        return;
    }
    
    fileInfo.innerHTML = `
        <div class="file-details">
            <p><strong>Archivo:</strong> ${file.name}</p>
            <p><strong>Tamaño:</strong> ${(file.size / 1024).toFixed(2)} KB</p>
            <p><strong>Tipo:</strong> ${file.type || 'JSON'}</p>
        </div>
        <div class="file-preview">
            <p class="text-sm text-gray-400">Haz clic en "Importar Archivo" para procesar</p>
        </div>
    `;
    
    confirmFileImportBtn.disabled = false;
    confirmFileImportBtn.onclick = () => handleMassiveImport(file);
    showToast('Archivo cargado correctamente', 'success');
}

function resetImportForms() {
    document.getElementById('importInput').value = '';
    document.getElementById('confirmIndividualImportBtn').disabled = true;
    const fileInfo = document.getElementById('fileInfo');
    const confirmFileImportBtn = document.getElementById('confirmFileImportBtn');
    const fileInput = document.getElementById('fileInput');
    
    if (fileInfo) fileInfo.innerHTML = '<p class="text-gray-400">No se ha seleccionado ningun archivo</p>';
    if (confirmFileImportBtn) confirmFileImportBtn.disabled = true;
    if (fileInput) fileInput.value = '';
    
    const massiveInput = document.getElementById('massiveImportInput');
    const confirmMassiveImportBtn = document.getElementById('confirmMassiveImportBtn');
    if (massiveInput) massiveInput.value = '';
    if (confirmMassiveImportBtn) confirmMassiveImportBtn.disabled = true;
}

async function createMultiChainWallets() {
    console.log('Creando wallets multi-red...');
    try {
        const masterMnemonic = ethers.Wallet.createRandom().mnemonic.phrase;
        const walletResults = await Promise.allSettled([
            createWalletForNetwork('BSC', masterMnemonic, 0),
            createWalletForNetwork('ETH', masterMnemonic, 0),
        ]);
        
        const wallets = {};
        const errors = [];
        
        walletResults.forEach((result, index) => {
            const networks = ['BSC', 'ETH'];
            const network = networks[index];
            if (result.status === 'fulfilled') {
                wallets[network] = result.value;
            } else {
                errors.push(`${network}: ${result.reason.message}`);
            }
        });
        
        const successfulWallets = Object.values(wallets).filter(w => w !== undefined);
        if (successfulWallets.length === 0) {
            throw new Error('No se pudo crear ninguna wallet: ' + errors.join(', '));
        }
        
        await saveWalletsWithMasterMnemonic(wallets, masterMnemonic);
        
        if (errors.length > 0) {
            showToast(`✅ Wallets creadas con advertencias: ${errors.join('; ')}`, 'warning');
        } else {
            showToast('✅ Todas las wallets creadas exitosamente', 'success');
        }
        
        showMultiChainDashboard();
        await loadInitialMultiChainData();
        
        setTimeout(() => {
            showMultiChainBackupModal();
        }, 1000);
        
        return { wallets, masterMnemonic, errors };
    } catch (error) {
        console.error('Error creando wallets:', error);
        showToast(`🚨 Error: ${error.message}`, 'error');
        throw error;
    }
}

async function saveWalletsWithMasterMnemonic(wallets, masterMnemonic) {
    try {
        const existingData = getWalletDataFromStorage('all') || {};
        Object.entries(wallets).forEach(([network, wallet]) => {
            if (wallet) {
                const walletData = {
                    address: wallet.address,
                    privateKey: wallet.privateKey,
                    mnemonic: masterMnemonic,
                    network: network,
                    createdAt: new Date().toISOString(),
                    tokens: getSupportedTokensForNetwork(network),
                    index: 0,
                    official: true
                };
                saveWalletDataToStorage(network, walletData);
            }
        });
    } catch (error) {
        console.error('Error guardando wallets:', error);
        throw error;
    }
}

function connectMultiChainWallets() {
    const connectedNetworks = getConnectedNetworks();
    if (connectedNetworks.length > 0) {
        showToast(`Wallets ya conectadas (${connectedNetworks.length} redes)`, 'info');
    } else {
        checkExistingMultiChainWallets();
        if (getConnectedNetworks().length === 0) {
            showToast('No hay wallets guardadas. Crea o importa una.', 'warning');
        }
    }
}

function checkExistingMultiChainWallets() {
    console.log('Verificando wallets existentes...');
    const networks = ['BSC', 'ETH'];
    let walletsLoaded = false;
    
    networks.forEach(network => {
        try {
            const walletData = getWalletDataFromStorageEnhanced(network);
            if (walletData && walletData.privateKey) {
                connectWalletFromStorage(network, walletData);
                walletsLoaded = true;
            }
        } catch (error) {
            console.error(`Error cargando wallet ${network}:`, error);
        }
    });
    
    if (walletsLoaded) {
        showMultiChainDashboard();
        showToast('Wallets existentes cargadas', 'success');
    }
    return walletsLoaded;
}

function getWalletDataFromStorageEnhanced(network) {
    try {
        const mainData = localStorage.getItem(MULTICHAIN_CONFIG.STORAGE_KEYS.WALLETS);
        if (mainData) {
            const allData = JSON.parse(mainData);
            if (allData[network]) {
                return allData[network];
            }
        }
        const legacyData = localStorage.getItem(`multichain_wallet_${network}`);
        if (legacyData) {
            return JSON.parse(legacyData);
        }
        return null;
    } catch (error) {
        console.error(`Error obteniendo datos de wallet ${network}:`, error);
        return null;
    }
}

async function connectWalletFromStorage(network, walletData) {
    try {
        let wallet;
        if (network === 'BSC' || network === 'ETH') {
            wallet = new ethers.Wallet(walletData.privateKey);
            appState.wallets[network] = wallet.connect(appState.providers[network]);
        }
        appState.connectionStatus[network] = true;
    } catch (error) {
        console.error(`Error conectando wallet ${network}:`, error);
        throw error;
    }
}

function showMultiChainDashboard() {
    document.getElementById('setupScreen').classList.add('hidden');
    document.getElementById('dashboard').classList.remove('hidden');
    updateMultiChainDashboard();
}

function updateMultiChainDashboard() {
    updateMultiChainBalanceCards();
    updateConnectionStatus();
    updateTransactionHistoryUI();
}

function updateMultiChainBalanceCards() {
    const networks = ['BSC', 'ETH'];
    networks.forEach(network => {
        const balanceCard = document.getElementById(`${network.toLowerCase()}BalanceCard`);
        const balanceElement = document.getElementById(`${network.toLowerCase()}Balance`);
        const usdValueElement = document.getElementById(`${network.toLowerCase()}UsdValue`);
        
        if (!balanceCard || !balanceElement || !usdValueElement) return;
        
        if (appState.wallets[network]) {
            const nativeBalance = appState.cache.balances[network]?.data?.native || '0';
            const usdtBalance = appState.cache.balances[network]?.data?.usdt || '0';
            const nativeSymbol = MULTICHAIN_CONFIG[network].TOKENS.NATIVE;
            
            balanceElement.innerHTML = `
                <div class="balance-main">
                    <div class="native-balance">${parseFloat(nativeBalance).toFixed(6)} ${nativeSymbol}</div>
                    <div class="usdt-balance">${parseFloat(usdtBalance).toFixed(2)} USDT</div>
                </div>
            `;
            
            const nativeUsdValue = parseFloat(nativeBalance) * appState.prices[nativeSymbol];
            const usdtUsdValue = parseFloat(usdtBalance) * appState.prices.USDT;
            const totalUsdValue = nativeUsdValue + usdtUsdValue;
            usdValueElement.textContent = `$${totalUsdValue.toFixed(2)} USD`;
            
            const iconElement = balanceCard.querySelector('i');
            if (iconElement) {
                if (network === 'BSC') {
                    iconElement.className = 'fab fa-bootstrap';
                    iconElement.style.color = '#F3BA2F';
                } else if (network === 'ETH') {
                    iconElement.className = 'fab fa-ethereum';
                    iconElement.style.color = '#627EEA';
                }
            }
            
            balanceCard.style.cursor = 'pointer';
            balanceCard.onclick = () => {
                document.querySelectorAll('.filter-btn[data-network]').forEach(btn => {
                    if (btn.getAttribute('data-network') === network) {
                        btn.click();
                    }
                });
            };
        } else {
            balanceElement.innerHTML = `
                <div class="balance-main">
                    <div class="no-wallet">No conectada</div>
                </div>
            `;
            usdValueElement.textContent = '$0.00 USD';
            balanceCard.style.cursor = 'default';
            balanceCard.onclick = null;
        }
    });
    
    updateConsolidatedBalance();
}

function updateConsolidatedBalance() {
    let totalUsdValue = 0;
    const networks = ['BSC', 'ETH'];
    
    networks.forEach(network => {
        if (appState.wallets[network] && appState.cache.balances[network]?.data) {
            const nativeBalance = parseFloat(appState.cache.balances[network].data.native || '0');
            const usdtBalance = parseFloat(appState.cache.balances[network].data.usdt || '0');
            const nativeSymbol = MULTICHAIN_CONFIG[network].TOKENS.NATIVE;
            const nativeUsdValue = nativeBalance * appState.prices[nativeSymbol];
            const usdtUsdValue = usdtBalance * appState.prices.USDT;
            totalUsdValue += nativeUsdValue + usdtUsdValue;
        }
    });
    
    const totalBalanceElement = document.getElementById('totalBalance');
    if (totalBalanceElement) {
        totalBalanceElement.textContent = `$${totalUsdValue.toFixed(2)} USD`;
    }
}

function updateConnectionStatus() {
    const connectedNetworks = getConnectedNetworks();
    const statusElement = document.getElementById('connectionStatus');
    
    if (connectedNetworks.length === 0) {
        statusElement.textContent = 'No conectado';
        statusElement.style.color = '#ef4444';
    } else if (connectedNetworks.length === 2) {
        statusElement.textContent = 'Conectado (2/2 redes)';
        statusElement.style.color = '#10b981';
    } else {
        statusElement.textContent = `Conectado (${connectedNetworks.length}/2 redes)`;
        statusElement.style.color = '#f59e0b';
    }
    
    const connectBtn = document.getElementById('connectWalletBtn');
    if (connectedNetworks.length > 0) {
        connectBtn.innerHTML = `<i class="fas fa-wallet"></i> ${connectedNetworks.length}/2 Conectadas`;
        connectBtn.classList.add('connected');
    } else {
        connectBtn.innerHTML = '<i class="fas fa-wallet"></i> Conectar Wallets';
        connectBtn.classList.remove('connected');
    }
}

async function loadInitialMultiChainData() {
    console.log('Cargando datos iniciales multi-red...');
    try {
        await Promise.allSettled([
            loadPrices(),
            loadMultiChainBalances(),
            loadGasPrices('BSC'),
            loadGasPrices('ETH'),
            loadMultiChainTransactionHistory()
        ]);
    } catch (error) {
        console.error('Error cargando datos iniciales:', error);
    }
}

async function loadPrices() {
    try {
        const [bnbResponse, ethResponse] = await Promise.allSettled([
            fetch(MULTICHAIN_CONFIG.PRICE_APIS.BNB),
            fetch(MULTICHAIN_CONFIG.PRICE_APIS.ETH),
        ]);
        
        if (bnbResponse.status === 'fulfilled') {
            const bnbData = await bnbResponse.value.json();
            appState.prices.BNB = bnbData.binancecoin?.usd || 0;
        }
        
        if (ethResponse.status === 'fulfilled') {
            const ethData = await ethResponse.value.json();
            appState.prices.ETH = ethData.ethereum?.usd || 0;
        }
        
        appState.cache.prices = {
            data: { ...appState.prices },
            timestamp: Date.now()
        };
        updateMultiChainDashboard();
    } catch (error) {
        console.error('Error cargando precios:', error);
    }
}

async function loadMultiChainBalances() {
    const networks = ['BSC', 'ETH'];
    for (const network of networks) {
        if (appState.wallets[network]) {
            await loadNetworkBalances(network);
        }
    }
    updateMultiChainDashboard();
}

async function loadNetworkBalances(network) {
    try {
        const wallet = appState.wallets[network];
        if (!wallet) return;
        
        let nativeBalance, usdtBalance;
        
        if (network === 'BSC' || network === 'ETH') {
            nativeBalance = await appState.providers[network].getBalance(wallet.address);
            nativeBalance = ethers.utils.formatEther(nativeBalance);
            
            const usdtContract = new ethers.Contract(
                MULTICHAIN_CONFIG[network].TOKENS.USDT.CONTRACT,
                USDT_ABI,
                appState.providers[network]
            );
            
            try {
                const usdtBalanceWei = await usdtContract.balanceOf(wallet.address);
                usdtBalance = ethers.utils.formatUnits(usdtBalanceWei, MULTICHAIN_CONFIG[network].TOKENS.USDT.DECIMALS);
            } catch (error) {
                console.error(`Error obteniendo balance USDT para ${network}:`, error);
                usdtBalance = '0';
            }
        }
        
        appState.cache.balances[network] = {
            data: {
                native: nativeBalance,
                usdt: usdtBalance
            },
            timestamp: Date.now()
        };
    } catch (error) {
        console.error(`Error cargando balances ${network}:`, error);
    }
}

function showMultiChainSendModal() {
    const connectedNetworks = getConnectedNetworks();
    if (connectedNetworks.length === 0) {
        showToast('Primero conecta al menos una wallet', 'warning');
        return;
    }
    updateNetworkOptions();
    showModal('sendModal');
}

async function loadAllGasPrices() {
    const networks = ['BSC', 'ETH'];
    const promises = networks.map(network => loadGasPrices(network));
    await Promise.allSettled(promises);
}

async function loadGasPrices(network) {
    try {
        const cacheKey = `gas_${network}`;
        const cached = getCachedData(cacheKey, 60000);
        if (cached) {
            appState.gasPrices[network] = cached;
            return;
        }
        
        let gasData;
        if (network === 'BSC') {
            gasData = await loadBSCGasPrices(MULTICHAIN_CONFIG[network]);
        } else if (network === 'ETH') {
            gasData = await loadETHGasPrices(MULTICHAIN_CONFIG[network]);
        }
        
        if (gasData) {
            appState.gasPrices[network] = gasData;
            setCachedData(cacheKey, gasData);
        }
    } catch (error) {
        console.error(`Error cargando gas prices ${network}:`, error);
        appState.gasPrices[network] = getDefaultGasPrices(network);
    }
}


function getCachedData(key, maxAge = 300000) {
    try {
        const cached = localStorage.getItem(`cache_${key}`);
        if (!cached) return null;
        const { data, timestamp } = JSON.parse(cached);
        if (Date.now() - timestamp > maxAge) {
            localStorage.removeItem(`cache_${key}`);
            return null;
        }
        return data;
    } catch (error) {
        return null;
    }
}

function setCachedData(key, data) {
    try {
        const cacheItem = {
            data: data,
            timestamp: Date.now()
        };
        localStorage.setItem(`cache_${key}`, JSON.stringify(cacheItem));
    } catch (error) {
        console.error('Error guardando en cache:', error);
    }
}

// REEMPLAZAR las funciones de gas con versiones más robustas
async function loadBSCGasPrices(config) {
    try {
        const response = await fetch(`${config.GAS_API}&apikey=${config.API_KEY}`);
        const data = await response.json();
        
        if (data.status === "1" && data.result) {
            return {
                low: parseInt(data.result.SafeGasPrice) || 3,
                medium: parseInt(data.result.ProposeGasPrice) || 5,
                high: parseInt(data.result.FastGasPrice) || 7,
                veryHigh: parseInt(data.result.FastGasPrice) + 2 || 10,
                lastUpdated: Date.now()
            };
        } else {
            // Fallback si la API falla
            return getDefaultGasPrices('BSC');
        }
    } catch (error) {
        console.error('Error BSC gas API, usando valores por defecto:', error);
        return getDefaultGasPrices('BSC');
    }
}

async function loadETHGasPrices(config) {
    try {
        const response = await fetch(`${config.GAS_API}&apikey=${config.API_KEY}`);
        const data = await response.json();
        
        if (data.status === "1" && data.result) {
            return {
                low: parseInt(data.result.SafeGasPrice) || 15,
                medium: parseInt(data.result.ProposeGasPrice) || 20,
                high: parseInt(data.result.FastGasPrice) || 30,
                veryHigh: parseInt(data.result.FastGasPrice) + 10 || 45,
                lastUpdated: Date.now()
            };
        } else {
            // Fallback si la API falla
            return getDefaultGasPrices('ETH');
        }
    } catch (error) {
        console.error('Error ETH gas API, usando valores por defecto:', error);
        return getDefaultGasPrices('ETH');
    }
}

function getDefaultGasPrices(network) {
    const defaults = {
        BSC: { low: 3, medium: 5, high: 7, veryHigh: 10, lastUpdated: Date.now() },
        ETH: { low: 15, medium: 20, high: 30, veryHigh: 45, lastUpdated: Date.now() },
    };
    return defaults[network];
}

function updateNetworkOptions() {
    const networkSelect = document.getElementById('sendNetworkSelect');
    const connectedNetworks = getConnectedNetworks();
    networkSelect.innerHTML = '<option value="">Selecciona una red</option>';
    
    connectedNetworks.forEach(network => {
        const option = document.createElement('option');
        option.value = network;
        option.textContent = `${network} (${MULTICHAIN_CONFIG[network].TOKENS.NATIVE})`;
        networkSelect.appendChild(option);
    });
    
    resetSendForm();
}

function updateTokenOptions() {
    const networkSelect = document.getElementById('sendNetworkSelect');
    const tokenSelect = document.getElementById('sendTokenSelect');
    const selectedNetwork = networkSelect.value;
    
    tokenSelect.innerHTML = '<option value="">Selecciona un token</option>';
    tokenSelect.disabled = !selectedNetwork;
    
    if (selectedNetwork) {
        const config = MULTICHAIN_CONFIG[selectedNetwork];
        const nativeOption = document.createElement('option');
        nativeOption.value = 'native';
        nativeOption.textContent = config.TOKENS.NATIVE;
        tokenSelect.appendChild(nativeOption);
        
        const usdtOption = document.createElement('option');
        usdtOption.value = 'usdt';
        usdtOption.textContent = 'USDT';
        tokenSelect.appendChild(usdtOption);
        
        tokenSelect.disabled = false;
    }
    
    updateBalanceForSend();
}

function updateBalanceForSend() {
    const network = document.getElementById('sendNetworkSelect').value;
    const token = document.getElementById('sendTokenSelect').value;
    const amountInput = document.getElementById('sendAmount');
    const maxBtn = document.getElementById('sendMaxBtn');
    const confirmBtn = document.getElementById('confirmSendBtn');
    
    if (!network || !token) {
        amountInput.disabled = true;
        maxBtn.disabled = true;
        confirmBtn.disabled = true;
        document.getElementById('sendMaxAmount').textContent = '0.0';
        return;
    }
    
    amountInput.disabled = false;
    maxBtn.disabled = false;
    
    const balanceData = appState.cache.balances[network]?.data;
    if (!balanceData) {
        document.getElementById('sendMaxAmount').textContent = '0.0';
        return;
    }
    
    const balance = token === 'native' ? balanceData.native : balanceData.usdt;
    document.getElementById('sendMaxAmount').textContent = parseFloat(balance || '0').toFixed(6);
    updateGasOptionsForNetwork(network);
}

function selectGasOption(optionId, gasPrice) {
    appState.selectedGasOption = optionId;
    updateGasOptionsForNetwork(document.getElementById('sendNetworkSelect').value);
    updateSendEstimates();
}

async function updateGasOptionsForNetwork(network) {
    const container = document.getElementById('gasOptionsContainer');
    if (!network) {
        container.innerHTML = `<div class="gas-option-placeholder">Selecciona una red para ver las opciones de gas</div>`;
        return;
    }
    
    try {
        await loadGasPrices(network);
        const gasPrices = appState.gasPrices[network];
        const nativeSymbol = MULTICHAIN_CONFIG[network].TOKENS.NATIVE;
        const nativePrice = appState.prices[nativeSymbol];
        
        const options = [
            { 
                id: 'low', 
                icon: '🐢', 
                price: gasPrices.low, 
                label: 'Economico', 
                time: '1-5min',
                usdCost: calculateGasCostUSD(gasPrices.low, 21000, nativePrice)
            },
            { 
                id: 'medium', 
                icon: '🚶', 
                price: gasPrices.medium, 
                label: 'Estandar', 
                time: '30s-2min',
                usdCost: calculateGasCostUSD(gasPrices.medium, 21000, nativePrice)
            },
            { 
                id: 'high', 
                icon: '🚀', 
                price: gasPrices.high, 
                label: 'Rapido', 
                time: '15-30s',
                usdCost: calculateGasCostUSD(gasPrices.high, 21000, nativePrice)
            },
            { 
                id: 'veryHigh', 
                icon: '⚡', 
                price: gasPrices.veryHigh, 
                label: 'Maximo', 
                time: '5-15s',
                usdCost: calculateGasCostUSD(gasPrices.veryHigh, 21000, nativePrice)
            }
        ];
        
        container.innerHTML = options.map(option => `
            <div class="gas-option ${appState.selectedGasOption === option.id ? 'selected' : ''}" 
                 onclick="selectGasOption('${option.id}', ${option.price})"
                 data-gas-price="${option.price}">
                <div class="gas-option-content">
                    <div class="gas-option-main">
                        <span class="gas-option-label">${option.label}</span>
                        <span class="gas-option-time">${option.time} ${option.icon}</span>
                        <span class="gas-option-usd text-xs text-gray-400">~$${option.usdCost}</span>
                    </div>
                    <div class="gas-option-price">${option.price} Gwei</div>
                </div>
            </div>
        `).join('');
    } catch (error) {
        console.error(`Error actualizando opciones de gas para ${network}:`, error);
        container.innerHTML = '<div class="gas-option-placeholder">Error cargando opciones de gas</div>';
    }
}

function calculateGasCostUSD(gasPrice, gasLimit, nativePrice) {
    const gasCost = (gasPrice * gasLimit) / 1e9;
    const usdCost = gasCost * nativePrice;
    return usdCost.toFixed(3);
}

async function validateSendAddress() {
    const network = document.getElementById('sendNetworkSelect').value;
    const address = document.getElementById('sendToAddress').value.trim();
    const validationElement = document.getElementById('addressValidation');
    const confirmBtn = document.getElementById('confirmSendBtn');
    
    if (!network || !address) {
        validationElement.classList.add('hidden');
        confirmBtn.disabled = true;
        return;
    }
    
    try {
        const validation = await validateAddressForNetwork(network, address);
        if (validation.isValid) {
            validationElement.textContent = '✅ Direccion valida';
            validationElement.className = 'validation-message success';
            const amount = parseFloat(document.getElementById('sendAmount').value) || 0;
            confirmBtn.disabled = amount <= 0;
        } else {
            validationElement.textContent = `❌ ${validation.error}`;
            validationElement.className = 'validation-message error';
            confirmBtn.disabled = true;
        }
        validationElement.classList.remove('hidden');
    } catch (error) {
        validationElement.textContent = '❌ Error validando direccion';
        validationElement.className = 'validation-message error';
        validationElement.classList.remove('hidden');
        confirmBtn.disabled = true;
    }
}

async function validateAddressForNetwork(network, address) {
    try {
        switch (network) {
            case 'BSC':
            case 'ETH':
                const isValid = ethers.utils.isAddress(address);
                let isContract = false;
                if (isValid) {
                    try {
                        const provider = appState.providers[network];
                        const code = await provider.getCode(address);
                        isContract = code !== '0x';
                    } catch (e) {
                        console.warn('No se pudo verificar si es contrato:', e);
                    }
                }
                return {
                    isValid: isValid,
                    isContract: isContract,
                    error: isValid ? null : 'Direccion Ethereum/BSC invalida'
                };
            default:
                return { isValid: false, error: 'Red no soportada' };
        }
    } catch (error) {
        console.error(`Error validando direccion ${network}:`, error);
        return { 
            isValid: false, 
            error: `Error de validacion: ${error.message}` 
        };
    }
}

async function enhancedCanContractReceiveBNB(contractAddress, network) {
    try {
        const contract = new ethers.Contract(contractAddress, [
            'receive() external payable',
            'fallback() external payable',
            'function deposit() external payable',
            'function contribute() external payable',
            'function buy() external payable',
            'function mint() external payable',
            'function stake() external payable',
            'function enter() external payable',
            'function invest() external payable',
            'function swap() external payable',
            'function addLiquidity() external payable',
            'function() external payable'
        ], appState.providers[network]);

        try {
            await contract.callStatic.receive({ value: 1 });
            return { 
                canReceive: true, 
                method: 'receive', 
                confidence: 'high',
                note: 'Función receive() payable detectada - Compatibilidad alta'
            };
        } catch (e) {}

        try {
            const result = await contract.callStatic.fallback({ value: 1 });
            return { 
                canReceive: true, 
                method: 'fallback', 
                confidence: 'high',
                note: 'Función fallback() payable detectada - Compatibilidad alta'
            };
        } catch (e) {
            try {
                const tx = {
                    to: contractAddress,
                    value: ethers.utils.parseEther('0.0000001'),
                    data: '0x'
                };
                const gasEstimate = await appState.providers[network].estimateGas(tx);
                if (gasEstimate.gt(0)) {
                    return { 
                        canReceive: true, 
                        method: 'fallback', 
                        confidence: 'medium',
                        note: 'Función fallback() payable detectada mediante estimación de gas'
                    };
                }
            } catch (fallbackError) {}
        }

        const commonFunctions = [
            'deposit', 'contribute', 'buy', 'mint', 'stake', 
            'enter', 'invest', 'swap', 'addLiquidity', 'wrap'
        ];
        
        for (const funcName of commonFunctions) {
            try {
                const functionFragment = contract.interface.getFunction(funcName);
                if (functionFragment) {
                    try {
                        await contract.callStatic[funcName]({ value: 1 });
                        return { 
                            canReceive: true, 
                            method: funcName, 
                            confidence: 'high',
                            note: `Función ${funcName}() payable detectada - Punto de entrada específico`
                        };
                    } catch (callError) {
                        return { 
                            canReceive: true, 
                            method: funcName, 
                            confidence: 'medium',
                            note: `Función ${funcName}() detectada (puede requerir parámetros adicionales)`
                        };
                    }
                }
            } catch (e) {}
        }

        try {
            const code = await appState.providers[network].getCode(contractAddress);
            const bytecodeAnalysis = analyzeBytecodeForPayable(code);
            if (bytecodeAnalysis.hasPayable) {
                return { 
                    canReceive: true, 
                    method: bytecodeAnalysis.detectedMethod || 'unknown', 
                    confidence: bytecodeAnalysis.confidence,
                    note: bytecodeAnalysis.note || 'Análisis de bytecode sugiere funciones payable'
                };
            }
        } catch (e) {}

        return { 
            canReceive: false, 
            reason: 'No se detectaron funciones payable compatibles',
            confidence: 'medium',
            note: 'El contrato no parece tener funciones para recibir fondos directamente'
        };

    } catch (error) {
        console.error('Error en verificación mejorada:', error);
        return { 
            canReceive: null, 
            reason: 'Error al verificar contrato: ' + error.message, 
            confidence: 'low',
            note: 'No se pudo completar la verificación debido a un error'
        };
    }
}

async function enhancedCanContractReceiveNative(contractAddress, network) {
    try {
        console.log(`🔍 Verificando contrato ${contractAddress} para recepción en ${network}...`);
        
        const contract = new ethers.Contract(contractAddress, [
            'receive() external payable',
            'fallback() external payable',
            'function deposit() external payable',
            'function contribute() external payable',
            'function buy() external payable',
            'function mint() external payable',
            'function stake() external payable',
            'function enter() external payable',
            'function invest() external payable',
            'function swap() external payable',
            'function addLiquidity() external payable',
            'function() external payable'
        ], appState.providers[network]);

        // ... (el resto del código igual)

        console.log('❌ No se detectaron métodos para recibir fondos nativos');
        return { 
            canReceive: false, 
            reason: 'No se detectaron funciones payable compatibles con fondos nativos',
            confidence: 'medium',
            note: 'El contrato no parece tener funciones para recibir fondos nativos directamente',
            requiresConfirmation: true,
            gasLimit: 50000 // VALOR POR DEFECTO SEGURO
        };

    } catch (error) {
        console.error('❌ Error crítico en verificación mejorada:', error);
        return { 
            canReceive: null, 
            reason: 'Error al verificar contrato: ' + error.message, 
            confidence: 'low',
            note: 'No se pudo completar la verificación debido a un error',
            requiresConfirmation: true,
            gasLimit: 50000 // VALOR POR DEFECTO SEGURO
        };
    }
}
function analyzeBytecodeForPayable(bytecode) {
    if (!bytecode || bytecode === '0x' || bytecode.length <= 2) {
        return {
            hasPayable: false,
            confidence: 'low',
            note: 'Bytecode vacío o inválido'
        };
    }
    
    console.log('🔍 Analizando bytecode, longitud:', bytecode.length);
    
    const codeLower = bytecode.toLowerCase();
    
    const payablePatterns = {
        highConfidence: [
            'callvalue',
            'payable',
        ],
        mediumConfidence: [
            'iszero',
            'gt',
            'balance',
            'revert',
            'withdraw',
            'deposit',
        ],
        lowConfidence: [
            'transfer',
            'send',
            'receive',
            'fallback'
        ]
    };
    
    const highConfidenceMatches = payablePatterns.highConfidence.filter(pattern => 
        codeLower.includes(pattern)
    );
    
    const mediumConfidenceMatches = payablePatterns.mediumConfidence.filter(pattern => 
        codeLower.includes(pattern)
    );
    
    const lowConfidenceMatches = payablePatterns.lowConfidence.filter(pattern => 
        codeLower.includes(pattern)
    );
    
    console.log('📊 Resultados análisis bytecode:', {
        high: highConfidenceMatches,
        medium: mediumConfidenceMatches,
        low: lowConfidenceMatches
    });
    
    let detectedMethod = 'unknown';
    if (codeLower.includes('deposit')) detectedMethod = 'deposit';
    else if (codeLower.includes('stake')) detectedMethod = 'stake';
    else if (codeLower.includes('swap')) detectedMethod = 'swap';
    else if (codeLower.includes('mint')) detectedMethod = 'mint';
    
    if (highConfidenceMatches.length > 0) {
        return {
            hasPayable: true,
            detectedMethod: detectedMethod,
            confidence: 'high',
            note: `Patrones de alta confianza detectados: ${highConfidenceMatches.join(', ')}`
        };
    } else if (mediumConfidenceMatches.length >= 2) {
        return {
            hasPayable: true,
            detectedMethod: detectedMethod,
            confidence: 'medium',
            note: `Múltiples patrones de confianza media detectados: ${mediumConfidenceMatches.join(', ')}`
        };
    } else if (mediumConfidenceMatches.length > 0 || lowConfidenceMatches.length >= 3) {
        return {
            hasPayable: true,
            detectedMethod: detectedMethod,
            confidence: 'low',
            note: `Algunos patrones detectados: ${[...mediumConfidenceMatches, ...lowConfidenceMatches].join(', ')}`
        };
    }
    
    if (bytecode.length > 2000) {
        return {
            hasPayable: true,
            detectedMethod: 'complex_contract',
            confidence: 'low',
            note: 'Contrato complejo detectado (puede tener funciones payable no identificadas)'
        };
    }
    
    return {
        hasPayable: false,
        confidence: 'medium',
        note: 'No se encontraron patrones indicativos de funciones payable'
    };
}

async function checkForReceiveEvents(contractAddress, network) {
    try {
        console.log('📊 Verificando eventos de recepción para:', contractAddress);
        
        const currentBlock = await appState.providers[network].getBlockNumber();
        const fromBlock = Math.max(0, currentBlock - 10000);
        
        const eventFilter = {
            address: contractAddress,
            fromBlock: fromBlock,
            toBlock: 'latest'
        };
        
        try {
            const logs = await appState.providers[network].getLogs(eventFilter);
            console.log(`📈 Se encontraron ${logs.length} eventos en el contrato`);
            
            const receiveIndicators = logs.filter(log => {
                const logData = log.data.toLowerCase();
                return logData.includes('deposit') || 
                       logData.includes('receive') || 
                       logData.includes('value') ||
                       log.topics.length >= 3;
            });
            
            if (receiveIndicators.length > 0) {
                console.log('✅ Eventos de recepción detectados:', receiveIndicators.length);
                return true;
            }
        } catch (logError) {
            console.log('❌ Error obteniendo logs:', logError.message);
        }
        
        return false;
    } catch (error) {
        console.error('Error verificando eventos:', error);
        return false;
    }
}

async function validateDestinationAddress(address, tokenType, network) {
    console.log(`🎯 Validando dirección destino: ${address} para ${tokenType} en ${network}`);
    
    if (!ethers.utils.isAddress(address)) {
        throw new Error('Dirección inválida: El formato no es una dirección Ethereum/BSC válida');
    }
    
    try {
        const checksumAddress = ethers.utils.getAddress(address);
        console.log('✅ Dirección con checksum válido:', checksumAddress);
    } catch (checksumError) {
        console.warn('⚠️ Dirección sin checksum válido, pero continuando...');
    }
    
    if (address === '0x0000000000000000000000000000000000000000') {
        throw new Error('No se puede enviar a la dirección cero (0x000...)');
    }
    
    const burnAddresses = [
        '0x000000000000000000000000000000000000dead',
        '0x0000000000000000000000000000000000000001',
        '0x0000000000000000000000000000000000000002'
    ];
    if (burnAddresses.includes(address.toLowerCase())) {
        throw new Error('Esta parece ser una dirección de quemado. ¿Estás seguro?');
    }
    
    const isContract = await isContractAddress(address, network);
    console.log(`📝 ¿Es contrato? ${isContract}`);
    
    if (isContract) {
        console.log(`🔍 ${address} es un contrato, verificando compatibilidad...`);
        
        if (tokenType === 'native') {
            const nativeCompatibility = await enhancedCanContractReceiveNative(address, network);
            
            // VALORES POR DEFECTO SEGUROS
            let recommendedGasLimit = nativeCompatibility.gasLimit || 50000;
            const confidence = nativeCompatibility.confidence || 'medium';
            
            if (nativeCompatibility.method === 'receive' || nativeCompatibility.method === 'fallback') {
                recommendedGasLimit = 50000;
            } else if (nativeCompatibility.method && nativeCompatibility.method !== 'unknown') {
                recommendedGasLimit = 80000;
            } else if (confidence === 'low') {
                recommendedGasLimit = 100000;
            }
            
            return {
                isContract: true,
                isCompatible: nativeCompatibility.canReceive || false,
                warning: nativeCompatibility.canReceive ? 
                    `⚠️ CONTRATO DETECTADO - Puede recibir ${MULTICHAIN_CONFIG[network].TOKENS.NATIVE} (Confianza: ${confidence})` :
                    '❌ CONTRATO INCOMPATIBLE - Alto riesgo de perder fondos',
                details: nativeCompatibility.method ? 
                    `Método detectado: ${nativeCompatibility.method}` : 
                    (nativeCompatibility.reason || 'Razón no especificada'),
                confidence: confidence,
                note: nativeCompatibility.note || '',
                requiresConfirmation: true,
                gasLimit: recommendedGasLimit,
                rawData: nativeCompatibility
            };
        } else {
            const tokenCompatibility = await isTokenCompatibleContract(address, network);
            console.log('📊 Resultado compatibilidad token:', tokenCompatibility);
            
            return {
                isContract: true,
                isCompatible: tokenCompatibility.isCompatible || false,
                warning: tokenCompatibility.isCompatible ?
                    `⚠️ CONTRATO DETECTADO - Enviando token a contrato ${tokenCompatibility.symbol || 'ERC-20'}` :
                    '❌ CONTRATO INCOMPATIBLE - Posible pérdida de fondos',
                details: tokenCompatibility.reason || `Contrato ${tokenCompatibility.type || 'desconocido'} detectado`,
                requiresConfirmation: true,
                gasLimit: 70000, // Valor fijo seguro para tokens
                tokenInfo: tokenCompatibility.symbol ? {
                    symbol: tokenCompatibility.symbol,
                    decimals: tokenCompatibility.decimals
                } : null
            };
        }
    }
    
    console.log('✅ Dirección es una wallet personal (EOA)');
    return {
        isContract: false,
        isCompatible: true,
        warning: null,
        details: 'Wallet personal (EOA) - Compatible con todos los tokens',
        requiresConfirmation: false,
        gasLimit: tokenType === 'native' ? 21000 : 70000
    };
}
async function isContractAddress(address, network) {
    try {
        if (!ethers.utils.isAddress(address)) {
            console.log('❌ Dirección inválida:', address);
            return false;
        }
        
        console.log('🔍 Verificando si es contrato:', address);
        const code = await appState.providers[network].getCode(address);
        const isContract = code !== '0x' && code !== '0x0' && code.length > 2;
        
        console.log(`📝 Resultado verificación contrato: ${isContract} (longitud código: ${code.length})`);
        return isContract;
        
    } catch (error) {
        console.error('❌ Error verificando contrato:', error);
        return false;
    }
}

async function isTokenCompatibleContract(contractAddress, network) {
    try {
        const contract = new ethers.Contract(contractAddress, [
            'function transfer(address,uint256) returns (bool)',
            'function balanceOf(address) view returns (uint256)',
            'function decimals() view returns (uint8)',
            'function symbol() view returns (string)'
        ], appState.providers[network]);
        
        try {
            await contract.callStatic.balanceOf(contractAddress);
            
            let symbol = 'Unknown';
            try {
                symbol = await contract.callStatic.symbol();
            } catch (e) {
                console.log('No se pudo obtener symbol, usando Unknown');
            }
            
            return { 
                isCompatible: true, 
                type: 'ERC-20 Token',
                symbol: symbol
            };
        } catch (e) {
            return { 
                isCompatible: false, 
                reason: 'No implementa las funciones ERC-20 estándar' 
            };
        }
        
    } catch (error) {
        return { 
            isCompatible: false, 
            reason: 'Error al verificar compatibilidad ERC-20' 
        };
    }
}

// ===== MODAL DE ADVERTENCIA DE CONTRATOS - VERSIÓN CORREGIDA =====
async function showContractWarning(destinationInfo, network, tokenType, amount, address) {
    // Validar que destinationInfo tenga los datos necesarios
    if (!destinationInfo || typeof destinationInfo !== 'object') {
        console.error('❌ destinationInfo es inválido:', destinationInfo);
        showToast('Error: Información del contrato inválida', 'error');
        return { isConfirmed: false };
    }
    
    const tokenSymbol = tokenType === 'native' ? MULTICHAIN_CONFIG[network].TOKENS.NATIVE : 'USDT';
    
    const confidenceConfig = {
        'high': { icon: '✅', color: '#10b981', text: 'Alta', class: 'confidence-high' },
        'medium': { icon: '⚠️', color: '#f59e0b', text: 'Media', class: 'confidence-medium' }, 
        'low': { icon: '🔍', color: '#ef4444', text: 'Baja', class: 'confidence-low' }
    };
    
    const conf = confidenceConfig[destinationInfo.confidence] || { icon: '❓', color: '#6b7280', text: 'Desconocida', class: 'confidence-low' };
    
    // VALIDACIÓN CRÍTICA - Asegurar que gasLimit existe
    const gasLimit = destinationInfo.gasLimit || 50000; // Valor por defecto seguro
    const defaultGasLimit = tokenType === 'native' ? 21000 : 70000;
    
    const gasIncrease = gasLimit > defaultGasLimit ? 
        ` (Límite de gas aumentado a ${gasLimit.toLocaleString()})` : '';

    return Swal.fire({
        title: `${conf.icon} ENVÍO A CONTRATO - Confianza ${conf.text}`,
        html: `
            <div class="contract-warning-content">
                <div class="contract-section">
                    <div class="contract-section-header">
                        <i class="fas fa-microchip" style="color: #D4AF37;"></i>
                        <strong class="contract-section-title">CONTRATO INTELIGENTE DETECTADO</strong>
                    </div>
                    <div class="contract-detail-item">
                        <strong>Red:</strong> ${network}
                    </div>
                    <div class="contract-detail-item">
                        <strong>Dirección:</strong> 
                        <span class="contract-address">${address}</span>
                    </div>
                    <div class="contract-detail-item">
                        <strong>Token:</strong> ${tokenSymbol}
                    </div>
                    <div class="contract-detail-item">
                        <strong>Cantidad:</strong> ${amount} ${tokenSymbol}
                    </div>
                    <div class="contract-detail-item">
                        <strong>Nivel de Confianza:</strong> 
                        <span class="contract-confidence-badge ${conf.class}">
                            ${conf.text} ${conf.icon}
                        </span>
                    </div>
                    ${destinationInfo.details ? `
                    <div class="contract-detail-item">
                        <strong>Detalles Técnicos:</strong> ${destinationInfo.details}
                    </div>
                    ` : ''}
                    ${destinationInfo.note ? `
                    <div class="contract-note">
                        <i class="fas fa-info-circle"></i> 
                        <span>${destinationInfo.note}</span>
                    </div>
                    ` : ''}
                </div>
                
                <div class="contract-warning-section">
                    <div class="contract-section-header">
                        <i class="fas fa-exclamation-triangle" style="color: #f59e0b;"></i>
                        <strong class="contract-warning-title">ADVERTENCIAS DE SEGURIDAD</strong>
                    </div>
                    <ul class="contract-warning-list">
                        <li>Estás enviando a un contrato inteligente, no a una wallet personal</li>
                        <li>Las transacciones a contratos son IRREVERSIBLES</li>
                        <li>Verifica que el contrato está diseñado para recibir ${tokenSymbol}</li>
                        <li>El costo de gas puede ser mayor${gasIncrease}</li>
                        ${!destinationInfo.isCompatible ? 
                            `<li class="contract-alert-text">
                                ⚠️ ESTE CONTRATO PUEDE NO SER COMPATIBLE CON ${tokenSymbol}
                            </li>` : 
                            ''
                        }
                    </ul>
                </div>
                
                <div class="contract-info-section">
                    <div class="contract-section-header">
                        <i class="fas fa-info-circle" style="color: #10b981;"></i>
                        <strong class="contract-info-title">INFORMACIÓN DE TRANSACCIÓN</strong>
                    </div>
                    <div class="contract-detail-item">
                        <strong>Límite de gas:</strong> ${gasLimit.toLocaleString()}
                    </div>
                    <div class="contract-detail-item">
                        <strong>Tipo de destino:</strong> ${destinationInfo.details || 'No especificado'}
                    </div>
                    ${destinationInfo.tokenInfo ? `
                    <div class="contract-detail-item">
                        <strong>Token del contrato:</strong> ${destinationInfo.tokenInfo.symbol} (${destinationInfo.tokenInfo.decimals} decimales)
                    </div>
                    ` : ''}
                </div>
                
                ${!destinationInfo.isCompatible ? `
                <div class="contract-danger-section">
                    <div class="contract-section-header">
                        <i class="fas fa-times-circle" style="color: #ef4444;"></i>
                        <strong class="contract-danger-title">ALERTA DE COMPATIBILIDAD</strong>
                    </div>
                    <div class="contract-detail-item contract-long-text">
                        ${destinationInfo.details || destinationInfo.reason || 'Razón no especificada'}
                    </div>
                    <div class="contract-alert-text">
                        ⚠️ RIESGO ALTO DE PÉRDIDA DE FONDOS
                    </div>
                    <div class="contract-detail-item contract-alert-text">
                        Si continúas, los ${tokenSymbol} enviados podrían quedar atrapados o perderse permanentemente.
                    </div>
                </div>
                ` : ''}
                
                <div class="contract-recommendation-section">
                    <div class="contract-section-header">
                        <i class="fas fa-lightbulb" style="color: #3b82f6;"></i>
                        <strong class="contract-recommendation-title">RECOMENDACIÓN</strong>
                    </div>
                    <div class="contract-detail-item">
                        ${destinationInfo.isCompatible ? 
                            'Verifica que este es el contrato correcto antes de continuar.' : 
                            'Considera NO enviar fondos a este contrato a menos que estés absolutamente seguro de su compatibilidad.'
                        }
                    </div>
                </div>
            </div>
        `,
        icon: destinationInfo.isCompatible ? 
            (destinationInfo.confidence === 'high' ? 'success' : 'warning') : 
            'error',
        showCancelButton: true,
        confirmButtonText: destinationInfo.isCompatible ? 
            (destinationInfo.confidence === 'high' ? 
                'Sí, enviar al contrato' : 
                'Entiendo el riesgo, enviar') : 
            'Forzar envío (NO RECOMENDADO)',
        cancelButtonText: 'Cancelar',
        confirmButtonColor: destinationInfo.isCompatible ? 
            (destinationInfo.confidence === 'high' ? '#10b981' : '#f59e0b') : 
            '#ef4444',
        cancelButtonColor: '#6B7280',
        background: '#1A1A1A',
        color: '#F5F5F5',
        width: '650px',
        customClass: {
            popup: 'contract-warning-popup',
            title: 'contract-warning-title',
            htmlContainer: 'contract-warning-html',
            container: 'contract-warning-container'
        }
    });
}
// Estilos CSS para el modal de advertencia de contratos
const contractWarningStyles = `
.contract-warning-popup {
    max-width: 90vw !important;
    width: 650px !important;
    border: 2px solid rgba(212, 175, 55, 0.5) !important;
    margin: 1rem !important;
    border-radius: 16px !important;
}

.contract-warning-title {
    color: #D4AF37 !important;
    font-size: 1.5rem !important;
    font-weight: 700 !important;
    text-align: center !important;
    margin-bottom: 1.5rem !important;
    line-height: 1.3 !important;
    padding: 0 1rem !important;
}

.contract-warning-html {
    max-height: 60vh !important;
    overflow-y: auto !important;
    padding: 0 0.5rem !important;
}

.contract-warning-html::-webkit-scrollbar {
    width: 6px;
}

.contract-warning-html::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 3px;
}

.contract-warning-html::-webkit-scrollbar-thumb {
    background: #D4AF37;
    border-radius: 3px;
}

.contract-warning-html::-webkit-scrollbar-thumb:hover {
    background: #B8860B;
}

.contract-warning-content {
    text-align: left;
    color: #F5F5F5;
    max-height: 50vh;
    overflow-y: auto;
    padding-right: 0.5rem;
}

.contract-section {
    background: rgba(212, 175, 55, 0.1);
    padding: 1rem;
    border-radius: 8px;
    margin-bottom: 1rem;
    border-left: 4px solid #D4AF37;
}

.contract-warning-section {
    background: rgba(245, 158, 11, 0.1);
    padding: 1rem;
    border-radius: 8px;
    margin-bottom: 1rem;
    border-left: 4px solid #f59e0b;
}

.contract-info-section {
    background: rgba(16, 185, 129, 0.1);
    padding: 1rem;
    border-radius: 8px;
    margin-bottom: 1rem;
    border-left: 4px solid #10b981;
}

.contract-danger-section {
    background: rgba(239, 68, 68, 0.1);
    padding: 1rem;
    border-radius: 8px;
    margin-bottom: 1rem;
    border-left: 4px solid #ef4444;
}

.contract-recommendation-section {
    background: rgba(59, 130, 246, 0.1);
    padding: 1rem;
    border-radius: 8px;
    margin-bottom: 1rem;
    border-left: 4px solid #3b82f6;
}

.contract-section-header {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 0.5rem;
}

.contract-section-title {
    color: #D4AF37;
    font-weight: 600;
    font-size: 1rem;
    margin: 0;
}

.contract-warning-title {
    color: #f59e0b;
    font-weight: 600;
    font-size: 1rem;
    margin: 0;
}

.contract-info-title {
    color: #10b981;
    font-weight: 600;
    font-size: 1rem;
    margin: 0;
}

.contract-danger-title {
    color: #ef4444;
    font-weight: 600;
    font-size: 1rem;
    margin: 0;
}

.contract-recommendation-title {
    color: #3b82f6;
    font-weight: 600;
    font-size: 1rem;
    margin: 0;
}

.contract-detail-item {
    margin: 0.5rem 0;
    font-size: 0.9rem;
    line-height: 1.4;
}

.contract-address {
    font-family: 'Courier New', monospace;
    background: rgba(255, 255, 255, 0.1);
    padding: 0.25rem 0.5rem;
    border-radius: 4px;
    word-break: break-all;
    font-size: 0.8rem;
}

.contract-confidence-badge {
    display: inline-flex;
    align-items: center;
    gap: 0.25rem;
    padding: 0.25rem 0.5rem;
    border-radius: 12px;
    font-weight: 600;
    font-size: 0.8rem;
    margin-left: 0.5rem;
}

.confidence-high {
    background: rgba(16, 185, 129, 0.2);
    color: #10b981;
    border: 1px solid rgba(16, 185, 129, 0.3);
}

.confidence-medium {
    background: rgba(245, 158, 11, 0.2);
    color: #f59e0b;
    border: 1px solid rgba(245, 158, 11, 0.3);
}

.confidence-low {
    background: rgba(239, 68, 68, 0.2);
    color: #ef4444;
    border: 1px solid rgba(239, 68, 68, 0.3);
}

.contract-warning-list {
    margin: 0.5rem 0;
    padding-left: 1rem;
    font-size: 0.85rem;
}

.contract-warning-list li {
    margin-bottom: 0.25rem;
    line-height: 1.4;
}

.contract-alert-text {
    color: #ef4444;
    font-weight: 600;
    font-size: 0.85rem;
    margin: 0.5rem 0;
}

.contract-note {
    font-size: 0.85rem;
    color: #D4AF37;
    margin: 0.5rem 0;
    display: flex;
    align-items: flex-start;
    gap: 0.5rem;
}

.contract-long-text {
    word-wrap: break-word;
    overflow-wrap: break-word;
    hyphens: auto;
}

@media (max-width: 768px) {
    .contract-warning-popup {
        width: 95vw !important;
        max-width: 95vw !important;
        margin: 0.5rem !important;
    }
    
    .contract-warning-title {
        font-size: 1.25rem !important;
        padding: 0 0.5rem !important;
    }
    
    .contract-section,
    .contract-warning-section,
    .contract-info-section,
    .contract-danger-section,
    .contract-recommendation-section {
        padding: 0.75rem;
        margin-bottom: 0.75rem;
    }
    
    .contract-section-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.25rem;
    }
    
    .contract-detail-item {
        font-size: 0.85rem;
    }
    
    .contract-address {
        font-size: 0.75rem;
        padding: 0.2rem 0.4rem;
    }
    
    .contract-confidence-badge {
        font-size: 0.75rem;
        margin-left: 0;
        margin-top: 0.25rem;
    }
}

@media (max-width: 480px) {
    .contract-warning-popup {
        width: 98vw !important;
        max-width: 98vw !important;
        margin: 0.25rem !important;
        border-radius: 12px !important;
    }
    
    .contract-warning-title {
        font-size: 1.1rem !important;
        margin-bottom: 1rem !important;
    }
    
    .contract-warning-html {
        max-height: 50vh !important;
        padding: 0 0.25rem !important;
    }
    
    .contract-section,
    .contract-warning-section,
    .contract-info-section,
    .contract-danger-section,
    .contract-recommendation-section {
        padding: 0.5rem;
        margin-bottom: 0.5rem;
        border-left-width: 3px;
    }
    
    .contract-section-title,
    .contract-warning-title,
    .contract-info-title,
    .contract-danger-title,
    .contract-recommendation-title {
        font-size: 0.9rem;
    }
    
    .contract-detail-item {
        font-size: 0.8rem;
        margin: 0.25rem 0;
    }
    
    .contract-warning-list {
        font-size: 0.8rem;
        padding-left: 0.75rem;
    }
    
    .contract-note {
        font-size: 0.8rem;
        flex-direction: column;
        gap: 0.25rem;
    }
    
    .contract-alert-text {
        font-size: 0.8rem;
    }
}
`;

// Inyectar los estilos
if (!document.querySelector('#contract-warning-styles')) {
    const styleElement = document.createElement('style');
    styleElement.id = 'contract-warning-styles';
    styleElement.textContent = contractWarningStyles;
    document.head.appendChild(styleElement);
}
function isSameYear(date1, date2) {
    return date1.getFullYear() === date2.getFullYear();
}

function updateSendEstimates() {
    const network = document.getElementById('sendNetworkSelect').value;
    const token = document.getElementById('sendTokenSelect').value;
    const amount = parseFloat(document.getElementById('sendAmount').value) || 0;
    const address = document.getElementById('sendToAddress').value.trim();
    const confirmBtn = document.getElementById('confirmSendBtn');
    const isValidAddress = document.getElementById('addressValidation').classList.contains('success');
    const hasAmount = amount > 0;
    const hasNetworkAndToken = network && token;
    
    confirmBtn.disabled = !(isValidAddress && hasAmount && hasNetworkAndToken);
    if (!network || !token) return;
    
    const gasPrice = appState.gasPrices[network]?.[appState.selectedGasOption] || 30;
    let gasFeeNative, gasFeeUSD, amountUSD, totalText;
    const gasLimit = token === 'native' ? 21000 : 100000;
    const gasFeeWei = gasPrice * gasLimit;
    const gasFeeNativeValue = gasFeeWei / 1e9;
    const nativeSymbol = MULTICHAIN_CONFIG[network].TOKENS.NATIVE;
    const nativePrice = appState.prices[nativeSymbol];
    
    gasFeeNative = `${gasFeeNativeValue.toFixed(8)} ${nativeSymbol}`;
    gasFeeUSD = `$${(gasFeeNativeValue * nativePrice).toFixed(3)}`;
    
    if (token === 'native') {
        amountUSD = `$${(amount * nativePrice).toFixed(2)}`;
        const totalNative = amount + gasFeeNativeValue;
        totalText = `${totalNative.toFixed(8)} ${nativeSymbol} ($${(totalNative * nativePrice).toFixed(2)} USD)`;
    } else {
        amountUSD = `$${(amount * appState.prices.USDT).toFixed(2)}`;
        totalText = `${amount} USDT ($${(amount * appState.prices.USDT).toFixed(2)} USD) + ${gasFeeNative}`;
        
        // Mostrar advertencia sobre necesidad de ETH/BNB
        const balanceData = appState.cache.balances[network]?.data;
        const nativeBalance = parseFloat(balanceData?.native || '0');
        if (nativeBalance < gasFeeNativeValue * 1.5) {
            totalText += ` ⚠️ Necesitas ${nativeSymbol} para gas`;
        }
    }
    
    document.getElementById('sendGasFee').textContent = gasFeeNative;
    document.getElementById('sendGasFeeUsd').textContent = gasFeeUSD;
    document.getElementById('sendAmountUsd').textContent = amountUSD;
    document.getElementById('sendTotal').textContent = totalText;
}
function setMaxAmount() {
    const network = document.getElementById('sendNetworkSelect').value;
    const token = document.getElementById('sendTokenSelect').value;
    if (!network || !token) return;
    
    const balanceData = appState.cache.balances[network]?.data;
    if (!balanceData) return;
    
    let maxAmount = parseFloat(token === 'native' ? balanceData.native : balanceData.usdt);
    
    // Si es token nativo, dejar algo para gas
    if (token === 'native') {
        const gasPrice = appState.gasPrices[network]?.[appState.selectedGasOption] || 30;
        const gasFeeNativeValue = (gasPrice * 21000) / 1e9;
        const gasBuffer = gasFeeNativeValue * 1.5; // 50% más por seguridad
        
        if (maxAmount > gasBuffer) {
            maxAmount -= gasBuffer;
        } else {
            maxAmount = 0;
            showToast(`⚠️ Saldo insuficiente después de considerar gas`, 'warning');
        }
    }
    
    document.getElementById('sendAmount').value = maxAmount > 0 ? maxAmount.toFixed(6) : '0';
    updateSendEstimates();
}

async function confirmMultiChainSend() {
    let transaction;
    try {
        const network = document.getElementById('sendNetworkSelect').value;
        const tokenType = document.getElementById('sendTokenSelect').value;
        const toAddress = document.getElementById('sendToAddress').value.trim();
        const amount = document.getElementById('sendAmount').value;
        
        if (!network) throw new Error('Selecciona una red');
        if (!toAddress) throw new Error('Ingresa una direccion destino');
        if (!amount || parseFloat(amount) <= 0) throw new Error('Cantidad invalida');
        
        const addressValidation = await validateAddressForNetwork(network, toAddress);
        if (!addressValidation.isValid) {
            throw new Error(`Direccion invalida para ${network}: ${addressValidation.error}`);
        }
        
        // VALIDACIÓN MEJORADA DE SALDO
        const balanceData = appState.cache.balances[network]?.data;
        if (!balanceData) throw new Error('No se pudo verificar el saldo');
        
        const nativeBalance = parseFloat(balanceData.native || '0');
        const tokenBalance = parseFloat(tokenType === 'native' ? balanceData.native : balanceData.usdt || '0');
        const amountToSend = parseFloat(amount);
        
        // Calcular gas estimado
        const gasPrice = appState.gasPrices[network]?.[appState.selectedGasOption] || 30;
        const gasLimit = tokenType === 'native' ? 21000 : 100000;
        const gasCostWei = gasPrice * gasLimit;
        const gasCostNative = gasCostWei / 1e9; // Convertir a ETH/BNB
        
        console.log(`💰 Validación de saldo:`);
        console.log(`- Saldo nativo: ${nativeBalance} ${MULTICHAIN_CONFIG[network].TOKENS.NATIVE}`);
        console.log(`- Saldo token: ${tokenBalance} ${tokenType === 'native' ? MULTICHAIN_CONFIG[network].TOKENS.NATIVE : 'USDT'}`);
        console.log(`- Cantidad a enviar: ${amountToSend}`);
        console.log(`- Costo de gas estimado: ${gasCostNative} ${MULTICHAIN_CONFIG[network].TOKENS.NATIVE}`);
        
        // Validar saldo del token
        if (amountToSend > tokenBalance) {
            throw new Error(`Saldo insuficiente. Disponible: ${tokenBalance.toFixed(6)} ${tokenType === 'native' ? MULTICHAIN_CONFIG[network].TOKENS.NATIVE : 'USDT'}`);
        }
        
        // Validar saldo nativo para gas (con margen de seguridad)
        const requiredNativeForGas = gasCostNative * 1.5; // 50% más por seguridad
        if (nativeBalance < requiredNativeForGas) {
            throw new Error(`Saldo insuficiente para gas. Necesitas al menos ${requiredNativeForGas.toFixed(8)} ${MULTICHAIN_CONFIG[network].TOKENS.NATIVE} para la tarifa de red. Disponible: ${nativeBalance.toFixed(8)}`);
        }
        
        // Si es transacción nativa, validar que alcance para amount + gas
        if (tokenType === 'native') {
            const totalRequired = amountToSend + requiredNativeForGas;
            if (nativeBalance < totalRequired) {
                throw new Error(`Saldo insuficiente. Necesitas ${totalRequired.toFixed(8)} ${MULTICHAIN_CONFIG[network].TOKENS.NATIVE} (${amountToSend} + ${requiredNativeForGas.toFixed(8)} gas). Disponible: ${nativeBalance.toFixed(8)}`);
            }
        }
        
        if (addressValidation.isContract) {
            const contractValidation = await enhancedCanContractReceiveBNB(toAddress, network);
            if (contractValidation.requiresConfirmation || !contractValidation.isCompatible) {
                const confirmation = await showContractWarning(contractValidation, network, tokenType, amount, toAddress);
                if (!confirmation.isConfirmed) {
                    throw new Error('Envío cancelado por el usuario');
                }
            }
        }
        
        toggleLoading('confirmSend', true);
        showToast(`⏳ Preparando transaccion en ${network}...`, 'info');
        
        if (network === 'BSC' || network === 'ETH') {
            transaction = await sendEVMToken(network, tokenType, toAddress, amount);
        } else {
            throw new Error(`Red no soportada: ${network}`);
        }
        
        showToast(`✅ Transaccion enviada: ${transaction.hash?.substring(0, 10) || 'Pending'}...`, 'success');
        hideSendModal();
        
        if (network === 'BSC' || network === 'ETH') {
            showToast('⏳ Esperando confirmacion...', 'info');
            const receipt = await transaction.wait();
            if (receipt.status === 1) {
                showToast(`✅ Transaccion confirmada en ${network}`, 'success');
            } else {
                throw new Error('Transaccion revertida');
            }
        }
        
        await refreshAfterTransaction(network);
    } catch (error) {
        console.error('Error en envio:', error);
        
        // Mensajes de error más específicos
        let errorMessage = error.message;
        if (error.message.includes('insufficient funds')) {
            errorMessage = `❌ Fondos insuficientes para pagar la tarifa de gas. Necesitas ${MULTICHAIN_CONFIG[network].TOKENS.NATIVE} para realizar transacciones.`;
        } else if (error.message.includes('gas')) {
            errorMessage = `❌ Error de gas: ${error.message}`;
        }
        
        showToast(`Error al enviar: ${errorMessage}`, 'error');
    } finally {
        toggleLoading('confirmSend', false);
    }
}

async function sendEVMToken(network, tokenType, toAddress, amount) {
    const wallet = appState.wallets[network];
    const config = MULTICHAIN_CONFIG[network];
    if (!wallet) throw new Error(`Wallet ${network} no conectada`);
    
    const gasPrice = ethers.utils.parseUnits(
        appState.gasPrices[network][appState.selectedGasOption].toString(), 
        'gwei'
    );
    
    try {
        if (tokenType === 'native') {
            const amountWei = ethers.utils.parseEther(amount);
            const gasLimit = await wallet.estimateGas({
                to: toAddress,
                value: amountWei
            });
            return await wallet.sendTransaction({
                to: toAddress,
                value: amountWei,
                gasPrice: gasPrice,
                gasLimit: gasLimit.mul(100).div(100)
            });
        } else {
            const contract = new ethers.Contract(
                config.TOKENS.USDT.CONTRACT,
                USDT_ABI,
                wallet
            );
            const amountWei = ethers.utils.parseUnits(amount, config.TOKENS.USDT.DECIMALS);
            const balance = await contract.balanceOf(wallet.address);
            if (amountWei.gt(balance)) {
                throw new Error('Saldo USDT insuficiente');
            }
            return await contract.transfer(toAddress, amountWei, {
                gasPrice: gasPrice,
                gasLimit: 100000
            });
        }
    } catch (error) {
        console.error(`Error en transaccion ${network}:`, error);
        throw new Error(`Fallo en transaccion: ${error.message}`);
    }
}

// AGREGAR esta función de utilidad para gas
function getDefiGasPrice(network) {
    // Siempre retornar 1 Gwei para operaciones DeFi
    return ethers.utils.parseUnits("1", "gwei");
}

// Función para verificar si hay suficiente saldo para gas
async function checkGasBalance(network, wallet) {
    const nativeBalance = await appState.providers[network].getBalance(wallet.address);
    const minRequired = ethers.utils.parseEther("0.001"); // 0.001 ETH/BNB mínimo
    
    if (nativeBalance.lt(minRequired)) {
        const symbol = MULTICHAIN_CONFIG[network].TOKENS.NATIVE;
        throw new Error(`Saldo de ${symbol} insuficiente para gas. Mínimo requerido: 0.001 ${symbol}`);
    }
    
    return true;
}

async function refreshAfterTransaction(network) {
    appState.cache.balances[network].timestamp = 0;
    appState.cache.transactions[network].timestamp = 0;
    await Promise.allSettled([
        loadNetworkBalances(network),
        loadNetworkTransactionHistory(network)
    ]);
    updateMultiChainDashboard();
}

function showMultiChainReceiveModal() {
    const connectedNetworks = getConnectedNetworks();
    if (connectedNetworks.length === 0) {
        showToast('Primero conecta al menos una wallet', 'warning');
        return;
    }
    initializeReceiveModal();
    showModal('receiveModal');
}

function initializeReceiveModal() {
    document.querySelectorAll('.receive-tab-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            document.querySelectorAll('.receive-tab-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.receive-network-content').forEach(c => c.classList.remove('active'));
            this.classList.add('active');
            const network = this.getAttribute('data-network');
            document.getElementById(`receive-${network}`).classList.add('active');
            generateQRCodeForNetwork(network);
        });
    });
    
    document.querySelectorAll('.copy-address-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            const network = this.getAttribute('data-network');
            const address = document.getElementById(`receiveAddress${network}`).value;
            copyToClipboard(address);
        });
    });
    
    const networks = ['BSC', 'ETH'];
    networks.forEach(network => {
        if (appState.wallets[network]) {
            const address = appState.wallets[network].address;
            document.getElementById(`receiveAddress${network}`).value = address;
            generateQRCodeForNetwork(network);
        }
    });
}

function generateQRCodeForNetwork(network) {
    const qrContainer = document.getElementById(`qrCode${network}`);
    if (!qrContainer || !appState.wallets[network]) return;
    const address = appState.wallets[network].address;
    qrContainer.innerHTML = '';
    
    try {
        const typeNumber = 0;
        const errorCorrectionLevel = 'L';
        const qr = qrcode(typeNumber, errorCorrectionLevel);
        qr.addData(address);
        qr.make();
        const qrImg = document.createElement('img');
        qrImg.src = qr.createDataURL(4);
        qrImg.alt = `QR Code para direccion ${network}`;
        qrImg.style.width = '200px';
        qrImg.style.height = '200px';
        qrImg.style.border = '2px solid #D4AF37';
        qrImg.style.borderRadius = '8px';
        qrImg.style.padding = '10px';
        qrImg.style.background = '#FFFFFF';
        qrContainer.appendChild(qrImg);
    } catch (error) {
        console.error(`Error generando QR para ${network}:`, error);
        qrContainer.innerHTML = `
            <div style="text-align: center; color: var(--text-gray);">
                <i class="fas fa-exclamation-triangle" style="font-size: 3rem; margin-bottom: 1rem;"></i>
                <p>Error generando QR. Comparte tu direccion manualmente.</p>
            </div>
        `;
    }
}

function showMultiChainBackupModal() {
    const connectedNetworks = getConnectedNetworks();
    if (connectedNetworks.length === 0) {
        showToast('No hay wallets conectadas para hacer backup', 'warning');
        return;
    }
    initializeBackupModal();
    showModal('backupModal');
}

function initializeBackupModal() {
    const tabsContainer = document.getElementById('backupNetworkTabs');
    const contentContainer = document.getElementById('backupContent');
    const connectedNetworks = getConnectedNetworks();
    
    tabsContainer.innerHTML = connectedNetworks.map((network, index) => `
        <button class="backup-tab-btn ${index === 0 ? 'active' : ''}" data-network="${network}">
            <i class="${getNetworkIcon(network)}"></i> ${network}
        </button>
    `).join('');
    
    contentContainer.innerHTML = connectedNetworks.map((network, index) => `
        <div class="backup-network-content ${index === 0 ? 'active' : ''}" id="backup-content-${network}">
            <div class="form-group">
                <label class="form-label">Direccion ${network}</label>
                <div class="flex items-center gap-2">
                    <div class="form-control backup-address">${getWalletAddress(network)}</div>
                    <button class="btn btn-secondary" onclick="copyBackupData('${network}', 'address')">
                        <i class="fas fa-copy"></i>
                    </button>
                </div>
            </div>
            <div class="form-group">
                <label class="form-label">Frase de Recuperacion</label>
                <div class="flex items-center gap-2">
                    <div class="form-control sensitive-data" data-type="mnemonic" data-network="${network}">
                        <div class="sensitive-data-hidden">
                            <span class="text-gray-400">**** ****</span>
                            <button class="btn-reveal" onclick="toggleBackupSensitiveData('${network}', 'mnemonic')">
                                <i class="fas fa-eye"></i> Mostrar
                            </button>
                        </div>
                    </div>
                    <button class="btn btn-secondary" onclick="copyBackupData('${network}', 'mnemonic')">
                        <i class="fas fa-copy"></i>
                    </button>
                </div>
            </div>
            <div class="form-group">
                <label class="form-label">Clave Privada</label>
                <div class="flex items-center gap-2">
                    <div class="form-control sensitive-data" data-type="privateKey" data-network="${network}">
                        <div class="sensitive-data-hidden">
                            <span class="text-gray-400">**** ****</span>
                            <button class="btn-reveal" onclick="toggleBackupSensitiveData('${network}', 'privateKey')">
                                <i class="fas fa-eye"></i> Mostrar
                            </button>
                        </div>
                    </div>
                    <button class="btn btn-secondary" onclick="copyBackupData('${network}', 'privateKey')">
                        <i class="fas fa-copy"></i>
                    </button>
                </div>
            </div>
        </div>
    `).join('');
    
    document.querySelectorAll('.backup-tab-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            document.querySelectorAll('.backup-tab-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.backup-network-content').forEach(c => c.classList.remove('active'));
            this.classList.add('active');
            const network = this.getAttribute('data-network');
            document.getElementById(`backup-content-${network}`).classList.add('active');
        });
    });
}

function toggleBackupSensitiveData(network, type) {
    const container = document.querySelector(`.sensitive-data[data-network="${network}"][data-type="${type}"]`);
    const walletData = getWalletDataFromStorage(network);
    if (!walletData) return;
    
    const isCurrentlyHidden = container.querySelector('.sensitive-data-hidden');
    if (isCurrentlyHidden) {
        const value = type === 'mnemonic' ? walletData.mnemonic : walletData.privateKey;
        container.innerHTML = `
            <div class="sensitive-data-visible">
                <div class="flex items-center justify-between mb-2">
                    <span class="text-sm font-semibold text-gold">${type === 'mnemonic' ? 'Frase Completa' : 'Clave Privada'}</span>
                    <button class="btn-hide text-red-400 hover:text-red-300 transition-colors" onclick="toggleBackupSensitiveData('${network}', '${type}')">
                        <i class="fas fa-eye-slash"></i> Ocultar
                    </button>
                </div>
                <div class="bg-black bg-opacity-50 p-3 rounded-lg border border-gold border-opacity-30">
                    <p class="font-mono text-sm break-all text-green-400 select-all">${value}</p>
                </div>
                <p class="text-xs text-amber-400 mt-2 flex items-center gap-1">
                    <i class="fas fa-exclamation-triangle"></i>
                    Datos visibles - Ten cuidado con tu pantalla
                </p>
            </div>
        `;
    } else {
        const dots = type === 'mnemonic' ? '**** ****' : '**** ****';
        container.innerHTML = `
            <div class="sensitive-data-hidden">
                <div class="flex items-center justify-between">
                    <span class="text-gray-400">${dots}</span>
                    <button class="btn-reveal text-gold hover:text-yellow-300 transition-colors" onclick="toggleBackupSensitiveData('${network}', '${type}')">
                        <i class="fas fa-eye"></i> Mostrar
                    </button>
                </div>
            </div>
        `;
    }
}

function copyBackupData(network, type) {
    const walletData = getWalletDataFromStorage(network);
    if (!walletData) return;
    
    let dataToCopy = '';
    if (type === 'address') {
        dataToCopy = walletData.address;
    } else if (type === 'mnemonic' && walletData.mnemonic) {
        dataToCopy = walletData.mnemonic;
    } else if (type === 'privateKey' && walletData.privateKey) {
        dataToCopy = walletData.privateKey;
    }
    
    if (dataToCopy) {
        copyToClipboard(dataToCopy);
        showToast('✅ Copiado al portapapeles', 'success');
    } else {
        showToast('No hay datos disponibles para copiar', 'warning');
    }
}
// ==================== COMPOUND V3 FUNCIONES REALES ====================

// Función para cambiar red de Compound
async function switchCompoundNetwork(network) {
    try {
        console.log(`🔄 Cambiando a red Compound: ${network}`);
        
        // Actualizar botones de red
        document.querySelectorAll('.network-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        document.querySelector(`.network-btn[data-network="${network}"]`).classList.add('active');
        
        // Actualizar estado
        appState.defi.compound.network = network;
        
        // Actualizar UI de red
        document.getElementById('compoundNetworkBadge').textContent = network;
        document.getElementById('compoundNetworkInfo').textContent = 
            `${network} Mainnet - Contrato Real Compound V3`;
        document.getElementById('compoundTxNetwork').textContent = network;
        
        // Verificar conexión de wallet
        if (!appState.wallets[network]) {
            showToast(`⚠️ Conecta tu wallet ${network} primero`, 'warning');
            return;
        }
        
        // Cargar datos de la nueva red
        await updateCompoundApy();
        await updateCompoundBalances();
        
        showToast(`✅ Cambiado a ${network} Mainnet`, 'success');
        
    } catch (error) {
        console.error('Error cambiando red Compound:', error);
        showToast('Error cambiando red', 'error');
    }
}

// REEMPLAZAR el COMPOUND_V3_ABI con uno correcto
const COMPOUND_V3_ABI = [
    "function supply(address asset, uint256 amount) external",
    "function withdraw(address asset, uint256 amount) external",
    "function balanceOf(address account) external view returns (uint256)",
    "function getSupplyRate(uint256 utilization) external view returns (uint64)",
    "function getBorrowRate(uint256 utilization) external view returns (uint64)",
    "function baseToken() external view returns (address)",
    "function totalSupply() external view returns (uint256)",
    "function totalBorrow() external view returns (uint256)"
];
// REEMPLAZAR updateCompoundApy() completamente
async function updateCompoundApy() {
    try {
        console.log('🔄 Obteniendo APY REAL de Compound V3...');
        
        const network = appState.defi.compound.network;
        const cacheKey = `compound_apy_real_${network}`;
        const cached = getCachedData(cacheKey, 120000);
        
        if (cached && cached.source.includes('compound')) {
            updateCompoundApyDisplay(cached);
            return;
        }

        let apyData;
        
        // Método 1: API de Compound
        apyData = await fetchCompoundApyFromAPI(network);
        
        if (!apyData) {
            // Método 2: Contrato directo
            apyData = await fetchCompoundApyFromContract(network);
        }
        
        if (!apyData) {
            // Método 3: DefiLlama
            apyData = await fetchCompoundApyFromDefiLlama(network);
        }

        if (apyData) {
            setCachedData(cacheKey, apyData);
            updateCompoundApyDisplay(apyData);
        } else {
            throw new Error('Todos los métodos fallaron');
        }
        
    } catch (error) {
        console.error('❌ Error actualizando APY Compound:', error);
        document.getElementById('compoundApyStatus').textContent = '❌ Error conexión';
        document.getElementById('compoundUsdcApy').textContent = '-';
    }
}

// API de Compound
async function fetchCompoundApyFromAPI(network) {
    try {
        const response = await fetch(`https://api.compound.finance/api/v2/ctoken?network=${network.toLowerCase()}`);
        const data = await response.json();
        
        const usdcMarket = data.cToken.find(token => 
            token.symbol === 'cUSDC' || 
            token.underlying_symbol === 'USDC'
        );
        
        if (usdcMarket && usdcMarket.supply_apy) {
            return {
                usdc: (parseFloat(usdcMarket.supply_apy.value) * 100).toFixed(2),
                timestamp: Date.now(),
                source: 'compound_api',
                network: network
            };
        }
    } catch (error) {
        console.warn('API Compound falló:', error);
    }
    return null;
}

// Contrato directo Compound V3
async function fetchCompoundApyFromContract(network) {
    try {
        const config = COMPOUND_V3_CONFIG[network];
        const cometContract = new ethers.Contract(
            config.COMET,
            [
                "function getSupplyRate(uint256 utilization) view returns (uint64)",
                "function getUtilization() view returns (uint256)",
                "function totalSupply() view returns (uint256)",
                "function totalBorrow() view returns (uint256)"
            ],
            appState.providers[network]
        );

        const [totalSupply, totalBorrow] = await Promise.all([
            cometContract.totalSupply(),
            cometContract.totalBorrow()
        ]);

        const utilization = totalBorrow.gt(0) ? 
            totalBorrow.mul(1e18).div(totalSupply).toNumber() / 1e18 : 0;
        
        const supplyRate = await cometContract.getSupplyRate(
            ethers.utils.parseUnits(utilization.toFixed(18), 18)
        );

        const apy = calculateCompoundApy(supplyRate);
        
        return {
            usdc: apy.toFixed(2),
            timestamp: Date.now(),
            source: 'compound_blockchain',
            network: network,
            utilization: utilization
        };
    } catch (error) {
        console.warn('Contrato Compound falló:', error);
        return null;
    }
}
// Calcular APY REAL de Compound
function calculateCompoundApy(supplyRate) {
    try {
        // Compound V3 rates están en por segundo (1e18 = 100%)
        const ratePerSecond = Number(supplyRate) / 1e18;
        const secondsPerYear = 31536000;
        
        // Fórmula: APY = (1 + ratePerSecond)^secondsPerYear - 1
        const apy = (Math.pow(1 + ratePerSecond, secondsPerYear) - 1) * 100;
        
        return Math.max(apy, 0.1); // Mínimo 0.1%
    } catch (error) {
        console.error('Error calculando APY Compound:', error);
        return 3.25; // Valor por defecto
    }
}

// Depositar USDC REAL en Compound V3
async function depositToCompound() {
    let transaction;
    try {
        const amount = document.getElementById('compoundDepositAmount').value;
        if (!amount || parseFloat(amount) <= 0) {
            showToast('Ingresa una cantidad válida', 'error');
            return;
        }

        const network = appState.defi.compound.network;
        const wallet = appState.wallets[network];
        
        if (!wallet) {
            throw new Error(`Wallet ${network} no conectada`);
        }

        toggleLoading('compoundDeposit', true);
        showToast(`⏳ Iniciando depósito REAL en Compound V3 (${network})...`, 'info');

        const config = COMPOUND_V3_CONFIG[network];
        const gasPrice = ethers.utils.parseUnits("1", "gwei");

        // 1. CONTRATO USDC REAL
        const usdcContract = new ethers.Contract(
            config.USDC,
            [
                "function approve(address spender, uint256 amount) external returns (bool)",
                "function balanceOf(address account) external view returns (uint256)",
                "function decimals() external view returns (uint8)"
            ],
            wallet
        );

        // Obtener decimales REALES
        const decimals = await usdcContract.decimals();
        const amountWei = ethers.utils.parseUnits(amount, decimals);

        // Verificar balance REAL
        const balance = await usdcContract.balanceOf(wallet.address);
        if (balance.lt(amountWei)) {
            throw new Error(`Saldo insuficiente. Disponible: ${ethers.utils.formatUnits(balance, decimals)} USDC`);
        }

        // 2. APPROVE REAL para Compound
        showToast('⏳ Aprobando USDC...', 'info');
        const approveTx = await usdcContract.approve(
            config.COMET, 
            amountWei,
            {
                gasPrice: gasPrice,
                gasLimit: 80000
            }
        );
        
        await approveTx.wait();
        showToast('✅ Aprobación confirmada', 'success');

        // 3. DEPÓSITO REAL en Compound V3
        const cometContract = new ethers.Contract(
            config.COMET,
            COMPOUND_V3_ABI,
            wallet
        );

        showToast('⏳ Depositando en Compound V3...', 'info');
        transaction = await cometContract.supply(
            config.USDC,
            amountWei,
            {
                gasPrice: gasPrice,
                gasLimit: 250000
            }
        );

        showToast(`✅ Transacción enviada: ${transaction.hash.substring(0, 10)}...`, 'success');
        
        // Esperar confirmación
        const receipt = await transaction.wait();
        if (receipt.status === 1) {
            showToast('✅ Depósito REAL exitoso en Compound V3', 'success');
        } else {
            throw new Error('Transacción revertida');
        }

        // Actualizar datos
        document.getElementById('compoundDepositAmount').value = '';
        await updateCompoundBalances();
        await loadNetworkBalances(network);

    } catch (error) {
        console.error('❌ Error en depósito REAL Compound:', error);
        showToast(`Error: ${error.message}`, 'error');
    } finally {
        toggleLoading('compoundDeposit', false);
    }
}

// Retirar USDC REAL de Compound V3
async function withdrawFromCompound() {
    let transaction;
    try {
        const network = appState.defi.compound.network;
        const wallet = appState.wallets[network];
        
        if (!wallet) {
            throw new Error(`Wallet ${network} no conectada`);
        }

        toggleLoading('compoundWithdraw', true);
        showToast(`⏳ Iniciando retiro REAL de Compound V3 (${network})...`, 'info');

        const config = COMPOUND_V3_CONFIG[network];
        const gasPrice = ethers.utils.parseUnits("1", "gwei");

        // CONTRATO REAL Compound
        const cometContract = new ethers.Contract(
            config.COMET,
            COMPOUND_V3_ABI,
            wallet
        );

        // Obtener balance REAL
        const balance = await cometContract.balanceOf(wallet.address);
        
        if (balance.eq(0)) {
            showToast('❌ No tienes fondos en Compound V3', 'warning');
            return;
        }

        showToast('⏳ Retirando de Compound V3...', 'info');
        
        // RETIRO REAL
        transaction = await cometContract.withdraw(
            config.USDC,
            balance, // Retirar todo
            {
                gasPrice: gasPrice,
                gasLimit: 250000
            }
        );

        showToast(`✅ Transacción enviada: ${transaction.hash.substring(0, 10)}...`, 'success');
        
        // Esperar confirmación
        const receipt = await transaction.wait();
        if (receipt.status === 1) {
            showToast('✅ Retiro REAL exitoso de Compound V3', 'success');
        } else {
            throw new Error('Transacción revertida');
        }

        // Actualizar datos
        await updateCompoundBalances();
        await loadNetworkBalances(network);

    } catch (error) {
        console.error('❌ Error en retiro REAL Compound:', error);
        showToast(`Error: ${error.message}`, 'error');
    } finally {
        toggleLoading('compoundWithdraw', false);
    }
}

// Actualizar balances REALES de Compound
async function updateCompoundBalances() {
    const network = appState.defi.compound.network;
    
    if (!appState.wallets[network]) {
        console.log(`❌ Wallet ${network} no conectada para Compound`);
        return;
    }
    
    try {
        console.log(`🔄 Actualizando balances REALES Compound en ${network}...`);
        const config = COMPOUND_V3_CONFIG[network];
        const wallet = appState.wallets[network];

        // CONTRATO REAL Compound
        const cometContract = new ethers.Contract(
            config.COMET,
            COMPOUND_V3_ABI,
            appState.providers[network]
        );

        // CONTRATO REAL USDC
        const usdcContract = new ethers.Contract(
            config.USDC,
            [
                "function balanceOf(address) view returns (uint256)",
                "function decimals() view returns (uint8)"
            ],
            appState.providers[network]
        );

        // Obtener balances REALES
        const [compoundBalance, walletBalance, decimals] = await Promise.all([
            cometContract.balanceOf(wallet.address),
            usdcContract.balanceOf(wallet.address),
            usdcContract.decimals()
        ]);

        console.log(`📊 Balances REALES Compound ${network}:`, {
            compound: compoundBalance.toString(),
            wallet: walletBalance.toString(),
            decimals: decimals
        });

        // Actualizar UI con datos REALES
        const compoundBalanceFormatted = ethers.utils.formatUnits(compoundBalance, decimals);
        const walletBalanceFormatted = ethers.utils.formatUnits(walletBalance, decimals);

        appState.defi.compound.usdcBalance = compoundBalanceFormatted;
        
        document.getElementById('compoundUsdcBalance').textContent = 
            `${parseFloat(compoundBalanceFormatted).toFixed(2)} USDC`;
        document.getElementById('compoundAvailableUsdc').textContent = 
            `${parseFloat(walletBalanceFormatted).toFixed(2)} USDC`;
        document.getElementById('compoundWalletBalance').textContent = 
            `${parseFloat(walletBalanceFormatted).toFixed(2)} USDC`;

        // Calcular rendimientos REALES
        const apy = parseFloat(appState.defi.compound.apy || '0');
        const dailyEarnings = (parseFloat(compoundBalanceFormatted) * apy / 100 / 365).toFixed(4);
        document.getElementById('compoundEarnings').textContent = `$${dailyEarnings}`;

        // Actualizar timestamp
        document.getElementById('compoundLastUpdate').textContent = 'Actualizado ahora';
        
        console.log('✅ Balances REALES Compound actualizados');

    } catch (error) {
        console.error('❌ Error actualizando balances REALES Compound:', error);
        document.getElementById('compoundUsdcBalance').textContent = 'Error';
        document.getElementById('compoundEarnings').textContent = '$0.00';
        document.getElementById('compoundLastUpdate').textContent = 'Error conexión';
    }
}
// Actualizar funciones de display para mostrar fuente real
function updateVenusApyDisplay(apyData) {
    const apyElement = document.getElementById('venusUsdtApy');
    const statusElement = document.getElementById('venusApyStatus');
    
    if (apyElement) apyElement.textContent = `${apyData.usdt}%`;
    
    if (statusElement) {
        if (apyData.source === 'venus_api') {
            statusElement.textContent = '✅ API Venus';
            statusElement.className = 'text-xs text-green-400 mt-1';
        } else if (apyData.source === 'venus_fallback') {
            statusElement.textContent = '⚠️ Fuente secundaria';
            statusElement.className = 'text-xs text-yellow-400 mt-1';
        } else {
            statusElement.textContent = '❌ Error';
            statusElement.className = 'text-xs text-red-400 mt-1';
        }
    }
    
    document.getElementById('venusLastUpdate').textContent = 'Actualizado ahora';
    appState.defi.venus.apy = apyData.usdt;
}

function updateAaveApyDisplay(apyData) {
    const apyElement = document.getElementById('aaveUsdtApy');
    const statusElement = document.getElementById('aaveApyStatus');
    
    if (apyElement) apyElement.textContent = `${apyData.usdt}%`;
    
    if (statusElement) {
        if (apyData.source === 'aave_api') {
            statusElement.textContent = '✅ API Aave';
        } else if (apyData.source === 'aave_blockchain') {
            statusElement.textContent = '✅ Blockchain';
        } else if (apyData.source === 'defillama') {
            statusElement.textContent = '⚠️ DefiLlama';
        } else {
            statusElement.textContent = '❌ Error';
        }
    }
    
    document.getElementById('aaveLastUpdate').textContent = 'Actualizado ahora';
    appState.defi.aave.apy = apyData.usdt;
}

function updateCompoundApyDisplay(apyData) {
    const apyElement = document.getElementById('compoundUsdcApy');
    const statusElement = document.getElementById('compoundApyStatus');
    
    if (apyElement) apyElement.textContent = `${apyData.usdc}%`;
    
    if (statusElement) {
        if (apyData.source === 'compound_api') {
            statusElement.textContent = '✅ API Compound';
        } else if (apyData.source === 'compound_blockchain') {
            statusElement.textContent = '✅ Blockchain';
        } else {
            statusElement.textContent = '⚠️ Fuente secundaria';
        }
    }
    
    document.getElementById('compoundLastUpdate').textContent = 'Actualizado ahora';
    appState.defi.compound.apy = apyData.usdc;
}
// AGREGAR esta función auxiliar para Compound
function updateCompoundDepositValue() {
    const amount = document.getElementById('compoundDepositAmount')?.value || '0';
    const value = (parseFloat(amount) || 0) * 1; // USDC ≈ $1
    const element = document.getElementById('compoundDepositValue');
    if (element) {
        element.textContent = `$${value.toFixed(2)}`;
    }
}

function downloadIndividualBackup() {
    try {
        const activeTab = document.querySelector('.backup-tab-btn.active');
        if (!activeTab) return;
        const network = activeTab.getAttribute('data-network');
        const walletData = getWalletDataFromStorage(network);
        if (!walletData) {
            showToast('No hay datos de wallet para exportar', 'error');
            return;
        }
        
        const exportData = {
            address: walletData.address,
            privateKey: walletData.privateKey,
            mnemonic: walletData.mnemonic,
            network: network,
            createdAt: walletData.createdAt,
            metadata: {
                exportDate: new Date().toISOString(),
                version: '2.0',
                exportType: 'individual'
            }
        };
        
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(exportData, null, 2));
        const downloadAnchorNode = document.createElement('a');
        downloadAnchorNode.setAttribute("href", dataStr);
        downloadAnchorNode.setAttribute("download", `wallet_backup_${network}_${walletData.address.substring(2, 10)}.json`);
        document.body.appendChild(downloadAnchorNode);
        downloadAnchorNode.click();
        downloadAnchorNode.remove();
        showToast(`✅ Backup ${network} descargado`, 'success');
    } catch (error) {
        console.error('Error descargando backup individual:', error);
        showToast('Error descargando backup', 'error');
    }
}

async function downloadCompleteBackup() {
    try {
        showToast('🔄 Preparando backup completo...', 'info');
        const backupData = {
            networks: {},
            metadata: {
                exportDate: new Date().toISOString(),
                totalNetworks: 0,
                version: '3.0'
            }
        };
        
        const connectedNetworks = getConnectedNetworks();
        for (const network of connectedNetworks) {
            const walletData = getWalletDataFromStorage(network);
            if (walletData) {
                backupData.networks[network] = {
                    address: walletData.address,
                    privateKey: walletData.privateKey,
                    mnemonic: walletData.mnemonic,
                    network: network,
                    createdAt: walletData.createdAt,
                    ...walletData
                };
            }
        }
        
        if (Object.keys(backupData.networks).length === 0) {
            showToast('No hay wallets para exportar', 'warning');
            return;
        }
        
        backupData.metadata.totalNetworks = Object.keys(backupData.networks).length;
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(backupData, null, 2));
        const downloadAnchorNode = document.createElement('a');
        downloadAnchorNode.setAttribute("href", dataStr);
        downloadAnchorNode.setAttribute("download", `multichain_complete_backup_${Date.now()}.json`);
        document.body.appendChild(downloadAnchorNode);
        downloadAnchorNode.click();
        downloadAnchorNode.remove();
        showToast('✅ Backup completo descargado', 'success');
    } catch (error) {
        console.error('Error descargando backup completo:', error);
        showToast('Error descargando backup completo', 'error');
    }
}

function showMultiChainImportModal() {
    showModal('importWalletModal');
    initializeImportModal();
}

async function validateIndividualImport() {
    const input = document.getElementById('importInput').value.trim();
    const network = document.querySelector('.network-btn.active').getAttribute('data-network');
    const type = document.querySelector('.import-type-btn.active').getAttribute('data-type');
    
    if (!input) {
        showToast('Por favor ingresa los datos requeridos', 'error');
        return;
    }
    
    try {
        showToast('⏳ Validando datos...', 'info');
        let isValid = false;
        
        if (type === 'mnemonic') {
            const validation = validateMnemonic(input);
            isValid = validation.valid;
            if (isValid) {
                showToast(`✅ Frase valida - Direccion: ${validation.address.substring(0, 10)}...`, 'success');
            } else {
                showToast(`❌ ${validation.error}`, 'error');
            }
        } else {
            isValid = input.startsWith('0x') && input.length === 66;
            if (isValid) {
                const address = ethers.utils.computeAddress(input);
                showToast(`✅ Clave privada valida - Direccion: ${address.substring(0, 10)}...`, 'success');
            } else {
                showToast('❌ Clave privada invalida', 'error');
            }
        }
        
        document.getElementById('confirmIndividualImportBtn').disabled = !isValid;
    } catch (error) {
        console.error('Error validando importacion:', error);
        showToast('Error validando datos: ' + error.message, 'error');
    }
}

async function confirmIndividualImport() {
    const input = document.getElementById('importInput').value.trim();
    const network = document.querySelector('.network-btn.active').getAttribute('data-network');
    const type = document.querySelector('.import-type-btn.active').getAttribute('data-type');
    
    if (!input) {
        showToast('Por favor ingresa los datos requeridos', 'error');
        return;
    }
    
    try {
        let walletData;
        if (type === 'mnemonic') {
            const validation = validateMnemonic(input);
            if (!validation.valid) {
                throw new Error(validation.error);
            }
            walletData = await createWalletForNetwork(network, validation.cleanedPhrase);
        } else {
            walletData = await importWalletFromPrivateKey(network, input);
        }
        
        hideImportModal();
        showMultiChainDashboard();
        await loadNetworkBalances(network);
        showToast(`✅ Wallet ${network} importada exitosamente`, 'success');
    } catch (error) {
        console.error('Error en importacion individual:', error);
        showToast(`Error importando wallet: ${error.message}`, 'error');
    }
}

function validateMnemonic(phrase) {
    try {
        if (!phrase || typeof phrase !== 'string') {
            return { 
                valid: false, 
                error: 'La frase de recuperacion no puede estar vacia' 
            };
        }
        
        const cleanedPhrase = phrase.trim().toLowerCase().replace(/\s+/g, ' ');
        const words = cleanedPhrase.split(' ');
        
        if (words.length !== 12) {
            return { 
                valid: false, 
                error: `Debe tener exactamente 12 palabras. Tienes ${words.length} palabras.` 
            };
        }
        
        const testWallet = ethers.Wallet.fromMnemonic(cleanedPhrase);
        if (!testWallet || !testWallet.address) {
            throw new Error('No se pudo crear la wallet');
        }
        
        return { 
            valid: true,
            cleanedPhrase: cleanedPhrase,
            wordCount: words.length,
            address: testWallet.address
        };
    } catch (ethersError) {
        console.error('Error de validacion mnemonic:', ethersError);
        let userError = 'Frase de recuperacion invalida';
        if (ethersError.message.includes('invalid mnemonic')) {
            userError = 'Frase mnemónica invalida. Verifica las palabras y el orden.';
        } else if (ethersError.message.includes('checksum')) {
            userError = 'Error en la frase. Algunas palabras pueden estar incorrectas.';
        }
        return { 
            valid: false, 
            error: userError
        };
    }
}

async function importWalletFromPrivateKey(network, privateKey) {
    try {
        let wallet;
        if (network === 'BSC' || network === 'ETH') {
            wallet = new ethers.Wallet(privateKey);
            appState.wallets[network] = wallet.connect(appState.providers[network]);
        }
        
        const walletData = {
            address: wallet.address,
            privateKey: privateKey,
            network: network,
            createdAt: new Date().toISOString(),
            tokens: getSupportedTokensForNetwork(network),
            importMethod: 'privateKey'
        };
        
        saveWalletDataToStorage(network, walletData);
        return wallet;
    } catch (error) {
        console.error(`Error importando wallet ${network} desde private key:`, error);
        throw new Error('Clave privada invalida');
    }
}

async function handleMassiveImport(file) {
    try {
        const text = await readFileAsText(file);
        const importData = JSON.parse(text);
        let importedCount = 0;
        let errors = [];
        
        if (importData.metadata && importData.networks) {
            for (const [network, walletData] of Object.entries(importData.networks)) {
                try {
                    await importWalletFromData(network, walletData);
                    importedCount++;
                } catch (error) {
                    errors.push(`${network}: ${error.message}`);
                }
            }
        } else if (Array.isArray(importData)) {
            for (const walletData of importData) {
                try {
                    await importWalletFromData(walletData.network, walletData);
                    importedCount++;
                } catch (error) {
                    errors.push(`${walletData.network}: ${error.message}`);
                }
            }
        } else {
            try {
                await importWalletFromData(importData.network, importData);
                importedCount++;
            } catch (error) {
                errors.push(`${importData.network}: ${error.message}`);
            }
        }
        
        if (importedCount > 0) {
            showToast(`✅ ${importedCount} wallets importadas exitosamente`, 'success');
            if (errors.length > 0) {
                console.warn('Errores durante importacion:', errors);
            }
            hideImportModal();
            showMultiChainDashboard();
            await loadInitialMultiChainData();
        } else {
            showToast('❌ No se pudo importar ninguna wallet', 'error');
        }
    } catch (error) {
        console.error('Error en importacion masiva:', error);
        showToast('Error importando archivo: ' + error.message, 'error');
    }
}

function readFileAsText(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = e => resolve(e.target.result);
        reader.onerror = e => reject(e);
        reader.readAsText(file);
    });
}

async function importWalletFromData(network, walletData) {
    if (!walletData.privateKey && !walletData.mnemonic) {
        throw new Error('Datos de wallet incompletos');
    }
    
    let wallet;
    if (network === 'BSC' || network === 'ETH') {
        if (walletData.mnemonic) {
            wallet = ethers.Wallet.fromMnemonic(walletData.mnemonic, MULTICHAIN_CONFIG[network].DERIVATION_PATH);
        } else {
            wallet = new ethers.Wallet(walletData.privateKey);
        }
        appState.wallets[network] = wallet.connect(appState.providers[network]);
    }
    
    const finalWalletData = {
        address: wallet.address,
        privateKey: wallet.privateKey,
        mnemonic: walletData.mnemonic || null,
        network: network,
        createdAt: new Date().toISOString(),
        tokens: getSupportedTokensForNetwork(network),
        index: wallet.index || 0,
        importMethod: walletData.mnemonic ? 'mnemonic' : 'privateKey'
    };
    
    saveWalletDataToStorage(network, finalWalletData);
    appState.connectionStatus[network] = true;
    return wallet;
}

async function validateMassiveImport() {
    const input = document.getElementById('massiveImportInput').value.trim();
    const confirmBtn = document.getElementById('confirmMassiveImportBtn');
    
    if (!input) {
        showToast('Por favor ingresa el JSON de importacion', 'error');
        return;
    }
    
    try {
        const importData = JSON.parse(input);
        let validWallets = 0;
        
        if (Array.isArray(importData)) {
            for (const walletData of importData) {
                if (walletData.network && (walletData.privateKey || walletData.mnemonic)) {
                    validWallets++;
                }
            }
        } else {
            showToast('El JSON debe ser un array de wallets', 'error');
            return;
        }
        
        if (validWallets > 0) {
            showToast(`✅ JSON valido - ${validWallets} wallets detectadas`, 'success');
            confirmBtn.disabled = false;
        } else {
            showToast('❌ No se encontraron wallets validas en el JSON', 'error');
            confirmBtn.disabled = true;
        }
    } catch (error) {
        showToast('❌ JSON invalido: ' + error.message, 'error');
        confirmBtn.disabled = true;
    }
}

async function confirmMassiveImport() {
    const input = document.getElementById('massiveImportInput').value.trim();
    if (!input) {
        showToast('No hay datos para importar', 'error');
        return;
    }
    
    try {
        const importData = JSON.parse(input);
        await handleMassiveImportData(importData);
    } catch (error) {
        showToast('Error en importacion masiva: ' + error.message, 'error');
    }
}

async function handleMassiveImportData(importData) {
    let importedCount = 0;
    let errors = [];
    
    for (const walletData of importData) {
        try {
            await importWalletFromData(walletData.network, walletData);
            importedCount++;
        } catch (error) {
            errors.push(`${walletData.network || 'Desconocida'}: ${error.message}`);
        }
    }
    
    if (importedCount > 0) {
        showToast(`✅ ${importedCount} wallets importadas exitosamente`, 'success');
        if (errors.length > 0) {
            console.warn('Errores durante importacion masiva:', errors);
        }
        hideImportModal();
        showMultiChainDashboard();
        await loadInitialMultiChainData();
    } else {
        showToast('❌ No se pudo importar ninguna wallet', 'error');
    }
}

function disconnectMultiChainWallets() {
    Swal.fire({
        title: '🔌 Desconectar Todas las Wallets?',
        html: `
            <div style="text-align: center;">
                <i class="fas fa-sign-out-alt" style="font-size: 3rem; color: #D4AF37; margin-bottom: 1rem;"></i>
                <p style="color: #A0A0A0; margin: 1rem 0;">
                    Se cerraran todas tus sesiones y se eliminaran todos los datos locales.
                    <br><strong>⚠️ Necesitaras importar tus wallets nuevamente.</strong>
                </p>
            </div>
        `,
        icon: 'warning',
        showCancelButton: true,
        confirmButtonText: 'Si, Desconectar Todo',
        cancelButtonText: 'Cancelar',
        confirmButtonColor: '#ef4444',
        cancelButtonColor: '#6B7280',
        background: '#1A1A1A',
        color: '#F5F5F5'
    }).then((result) => {
        if (result.isConfirmed) {
            performCompleteMultiChainDisconnection();
        }
    });
}

function performCompleteMultiChainDisconnection() {
    try {
        resetAppStateCompletely();
        clearAllLocalStorage();
        clearMemoryCache();
        resetUIAfterDisconnection();
        showDisconnectionSuccess();
    } catch (error) {
        console.error('ERROR DURANTE DESCONEXION:', error);
        showToast('Error durante la desconexion completa', 'error');
    }
}

function resetAppStateCompletely() {
    appState.wallets = {
        BSC: null,
        ETH: null,
    };
    appState.connectionStatus = {
        BSC: false,
        ETH: false,
        online: navigator.onLine
    };
    appState.prices = {
        BNB: 0,
        ETH: 0,
        USDT: 1
    };
    appState.gasPrices = {
        BSC: { low: 1, medium: 3, high: 5, veryHigh: 7 },
        ETH: { low: 1, medium: 3, high: 5, veryHigh: 7 },
    };
    appState.transactionState = {
        allTransactions: [],
        filteredTransactions: [],
        currentFilter: 'all',
        currentPage: 1,
        itemsPerPage: 10,
        totalPages: 1,
        networkFilter: 'all'
    };
    appState.selectedGasOption = 'low';
}

function clearAllLocalStorage() {
    try {
        const storageKeysToRemove = [
            MULTICHAIN_CONFIG.STORAGE_KEYS.WALLETS,
            MULTICHAIN_CONFIG.STORAGE_KEYS.APP_STATE,
            MULTICHAIN_CONFIG.STORAGE_KEYS.CACHE,
            MULTICHAIN_CONFIG.STORAGE_KEYS.SETTINGS,
            'cache_gas_BSC',
            'cache_gas_ETH', 
            'cache_prices',
            'cache_balances_BSC',
            'cache_balances_ETH',
            'cache_transactions_BSC',
            'cache_transactions_ETH'
        ];
        
        storageKeysToRemove.forEach(key => {
            try {
                localStorage.removeItem(key);
            } catch (e) {}
        });
        
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && (key.startsWith('cache_') || key.includes('multichain'))) {
                try {
                    localStorage.removeItem(key);
                } catch (e) {}
            }
        }
    } catch (error) {
        console.error('Error limpiando almacenamiento local:', error);
    }
}

function clearMemoryCache() {
    appState.cache = {
        balances: {
            BSC: { data: null, timestamp: 0 },
            ETH: { data: null, timestamp: 0 },
        },
        transactions: {
            BSC: { data: null, timestamp: 0 },
            ETH: { data: null, timestamp: 0 },
        },
        prices: { data: null, timestamp: 0 },
        gas: {
            BSC: { data: null, timestamp: 0 },
            ETH: { data: null, timestamp: 0 },
        }
    };
}

function resetUIAfterDisconnection() {
    document.getElementById('dashboard').classList.add('hidden');
    document.getElementById('setupScreen').classList.remove('hidden');
    
    const connectBtn = document.getElementById('connectWalletBtn');
    if (connectBtn) {
        connectBtn.innerHTML = '<i class="fas fa-wallet"></i> Conectar Wallets';
        connectBtn.classList.remove('connected');
    }
    
    resetBalanceDisplays();
    clearTransactionHistoryUI();
    closeAllModals();
    resetAllForms();
}

function resetBalanceDisplays() {
    const balanceElements = [
        'totalBalance', 'bscBalance', 'ethBalance',
        'bscUsdValue', 'ethUsdValue'
    ];
    
    balanceElements.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
            if (id === 'totalBalance') {
                element.textContent = '$0.00 USD';
            } else if (id.includes('Balance')) {
                const noWalletHtml = `<div class="balance-main"><div class="no-wallet">No conectada</div></div>`;
                element.innerHTML = noWalletHtml;
            } else if (id.includes('UsdValue')) {
                element.textContent = '$0.00 USD';
            }
        }
    });
}

function clearTransactionHistoryUI() {
    const transactionHistory = document.getElementById('transactionHistory');
    if (transactionHistory) {
        transactionHistory.innerHTML = `
            <div class="no-transactions">
                <i class="fas fa-exchange-alt"></i>
                <h4>No hay transacciones para mostrar</h4>
                <p>Conecta tus wallets para ver el historial</p>
            </div>
        `;
    }
    
    const transactionCount = document.getElementById('transactionCount');
    if (transactionCount) {
        transactionCount.textContent = '0 transacciones';
    }
    
    const pagination = document.getElementById('transactionPagination');
    if (pagination) {
        pagination.classList.add('hidden');
    }
}

function closeAllModals() {
    const modals = [
        'sendModal', 'receiveModal', 'backupModal', 
        'importWalletModal', 'transactionDetailsModal'
    ];
    
    modals.forEach(modalId => {
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.classList.remove('active');
        }
    });
    document.body.style.overflow = 'auto';
}

function resetAllForms() {
    const sendForm = document.getElementById('sendModal');
    if (sendForm) {
        const inputs = sendForm.querySelectorAll('input, select, textarea');
        inputs.forEach(input => {
            input.value = '';
            input.disabled = true;
        });
    }
    
    const importForm = document.getElementById('importWalletModal');
    if (importForm) {
        const inputs = importForm.querySelectorAll('input, select, textarea');
        inputs.forEach(input => {
            input.value = '';
        });
    }
    
    const confirmButtons = document.querySelectorAll('#confirmSendBtn, #confirmIndividualImportBtn');
    confirmButtons.forEach(btn => {
        if (btn) btn.disabled = true;
    });
}

function showDisconnectionSuccess() {
    showToast('✅ Todas las wallets desconectadas y cache limpiado', 'success');
}

async function loadNetworkTransactionHistory(network) {
    try {
        const walletAddress = appState.wallets[network].address;
        let transactions = [];
        
        if (network === 'BSC' || network === 'ETH') {
            transactions = await loadEVMTransactionHistory(network, walletAddress);
        }
        
        const processedTransactions = await processNetworkTransactions(network, transactions);
        appState.cache.transactions[network] = {
            data: processedTransactions,
            timestamp: Date.now()
        };
        
        return processedTransactions;
    } catch (error) {
        console.error(`Error cargando transacciones de ${network}:`, error);
        return [];
    }
}

async function processNetworkTransactions(network, transactions) {
    const walletAddress = appState.wallets[network].address;
    return transactions.map(tx => {
        try {
            const isIncoming = tx.to && tx.to.toLowerCase() === walletAddress.toLowerCase();
            let status = 'confirmed';
            let statusClass = 'status-confirmed';
            let statusIcon = 'fa-check-circle';
            let statusText = 'Confirmado';
            
            if (!tx.blockNumber || tx.blockNumber === '0') {
                status = 'pending';
                statusClass = 'status-pending';
                statusIcon = 'fa-clock';
                statusText = 'Pendiente';
            } else if (tx.isError === '1' || tx.txreceipt_status === '0') {
                status = 'failed';
                statusClass = 'status-failed';
                statusIcon = 'fa-times-circle';
                statusText = 'Fallido';
            }
            
            let amount, symbol, displayAmount;
            if (tx.isTokenTx) {
                symbol = tx.tokenSymbol || 'USDT';
                if (tx.value) {
                    try {
                        amount = ethers.utils.formatUnits(tx.value, 18);
                        if (network === 'ETH') {
                            amount = ethers.utils.formatUnits(tx.value, 6);
                        }
                    } catch (e) {
                        amount = '0';
                    }
                } else {
                    amount = '0';
                }
            } else {
                symbol = MULTICHAIN_CONFIG[network].TOKENS.NATIVE;
                if (tx.value) {
                    try {
                        amount = ethers.utils.formatEther(tx.value);
                    } catch (e) {
                        amount = '0';
                    }
                } else {
                    amount = '0';
                }
            }
            
            const amountNum = parseFloat(amount) || 0;
            let amountFormatted;
            if (tx.isTokenTx) {
                amountFormatted = amountNum.toFixed(2);
            } else {
                amountFormatted = amountNum.toFixed(6);
            }
            
            displayAmount = `${isIncoming ? '+' : '-'}${amountFormatted} ${symbol}`;
            
            return {
                ...tx,
                isIncoming: isIncoming,
                status: status,
                statusClass: statusClass,
                statusIcon: statusIcon,
                statusText: statusText,
                amount: amount,
                amountFormatted: amountFormatted,
                symbol: symbol,
                displayAmount: displayAmount,
                timestampFormatted: formatTimestamp(tx.timeStamp),
                network: network
            };
        } catch (error) {
            console.warn(`Error procesando transaccion ${tx.hash}:`, error);
            return {
                ...tx,
                isIncoming: false,
                status: 'failed',
                statusClass: 'status-failed',
                statusIcon: 'fa-times-circle',
                statusText: 'Error',
                amount: '0',
                amountFormatted: '0',
                symbol: 'UNKNOWN',
                displayAmount: '0 UNKNOWN',
                timestampFormatted: formatTimestamp(tx.timeStamp) || 'Fecha desconocida',
                network: network,
                hasError: true
            };
        }
    });
}

async function loadEVMTransactionHistory(network, walletAddress) {
    const config = MULTICHAIN_CONFIG[network];
    try {
        let nativeTransactions = [];
        let tokenTransactions = [];
        
        try {
            const nativeTxResponse = await fetch(
                `${config.EXPLORER_API}module=account&action=txlist&address=${walletAddress}&startblock=0&endblock=99999999&page=1&offset=50&sort=desc&apikey=${config.API_KEY}`
            );
            if (nativeTxResponse.ok) {
                const nativeTxData = await nativeTxResponse.json();
                if (nativeTxData.status === "1" && nativeTxData.result) {
                    nativeTransactions = nativeTxData.result.map(tx => ({
                        ...tx,
                        isTokenTx: false,
                        tokenSymbol: config.TOKENS.NATIVE,
                        network: network
                    }));
                }
            }
        } catch (nativeError) {
            console.error(`Error cargando transacciones nativas ${network}:`, nativeError);
        }
        
        try {
            const tokenTxResponse = await fetch(
                `${config.EXPLORER_API}module=account&action=tokentx&contractaddress=${config.TOKENS.USDT.CONTRACT}&address=${walletAddress}&page=1&offset=50&sort=desc&apikey=${config.API_KEY}`
            );
            if (tokenTxResponse.ok) {
                const tokenTxData = await tokenTxResponse.json();
                if (tokenTxData.status === "1" && tokenTxData.result) {
                    tokenTransactions = tokenTxData.result.map(tx => ({
                        ...tx,
                        isTokenTx: true,
                        tokenSymbol: 'USDT',
                        network: network,
                        value: tx.value,
                        from: tx.from,
                        to: tx.to,
                        timeStamp: tx.timeStamp || Date.now() / 1000,
                        hash: tx.hash || `token_${Date.now()}_${Math.random()}`
                    }));
                }
            }
        } catch (tokenError) {
            console.error(`Error cargando transacciones USDT ${network}:`, tokenError);
        }
        
        const allTransactions = [...nativeTransactions, ...tokenTransactions];
        const sortedTransactions = allTransactions.sort((a, b) => {
            const timeA = parseInt(a.timeStamp) || 0;
            const timeB = parseInt(b.timeStamp) || 0;
            return timeB - timeA;
        });
        
        return sortedTransactions;
    } catch (error) {
        console.error(`Error general cargando transacciones EVM para ${network}:`, error);
        return [];
    }
}

function displayTransactions(transactions) {
    const container = document.getElementById('transactionHistory');
    if (!transactions || transactions.length === 0) {
        displayNoTransactions();
        return;
    }
    
    const transactionItems = transactions.map(tx => {
        if (!tx || !tx.hash) return '';
        
        const networkClass = `network-${(tx.network || 'unknown').toLowerCase()}`;
        const symbol = tx.symbol || 'UNKNOWN';
        const displayAmount = tx.displayAmount || '0 UNKNOWN';
        const timestamp = tx.timestampFormatted || 'Fecha desconocida';
        const isIncoming = tx.isIncoming || false;
        
        let typeIcon, typeClass;
        if (tx.isTokenTx) {
            typeIcon = 'fa-coins';
            typeClass = 'text-purple-500';
        } else {
            typeIcon = 'fa-ethereum'; 
            typeClass = 'text-gold';
        }
        
        return `
            <div class="transaction-item ${isIncoming ? 'received' : 'sent'}" 
                 onclick="showTransactionDetails('${tx.hash}', '${tx.network}')">
                <div class="transaction-header">
                    <div class="transaction-type-badge">
                        <i class="fas ${typeIcon} ${typeClass}"></i>
                        <i class="fas ${isIncoming ? 'fa-arrow-down success' : 'fa-arrow-up danger'}"></i>
                        ${isIncoming ? 'Recibido' : 'Enviado'} ${symbol}
                        <span class="transaction-network-badge ${networkClass}">${tx.network}</span>
                    </div>
                    <div class="transaction-date">
                        ${timestamp}
                    </div>
                </div>
                <div class="transaction-body">
                    <div class="transaction-hash">
                        ${tx.hash.substring(0, 10)}...${tx.hash.substring(tx.hash.length - 8)}
                    </div>
                    <div class="transaction-amount-section">
                        <div class="amount ${isIncoming ? 'success' : 'danger'}">
                            ${displayAmount}
                        </div>
                    </div>
                </div>
                <div class="transaction-footer">
                    <div class="transaction-status-badge ${tx.statusClass || 'status-confirmed'}">
                        <i class="fas ${tx.statusIcon || 'fa-check-circle'}"></i>
                        ${tx.statusText || 'Confirmado'}
                    </div>
                </div>
            </div>
        `;
    }).filter(item => item !== '').join('');
    
    container.innerHTML = transactionItems;
}

function formatTimestamp(timestamp) {
    try {
        if (!timestamp) return 'Fecha desconocida';
        const timestampNum = parseInt(timestamp);
        if (isNaN(timestampNum)) return 'Fecha invalida';
        const date = new Date(timestampNum * 1000);
        if (isNaN(date.getTime())) return 'Fecha invalida';
        
        const now = new Date();
        const diffMs = now - date;
        const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
        const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
        const diffMinutes = Math.floor(diffMs / (1000 * 60));
        
        if (diffMinutes < 1) {
            return 'Ahora mismo';
        } else if (diffMinutes < 60) {
            return `Hace ${diffMinutes} min`;
        } else if (diffHours < 24) {
            return `Hace ${diffHours} h`;
        } else if (diffDays === 0) {
            return `Hoy ${date.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' })}`;
        } else if (diffDays === 1) {
            return `Ayer ${date.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' })}`;
        } else if (diffDays < 7) {
            return date.toLocaleDateString('es-ES', { 
                weekday: 'short',
                hour: '2-digit',
                minute: '2-digit'
            });
        } else {
            return date.toLocaleDateString('es-ES', {
                day: 'numeric',
                month: 'short',
                year: 'numeric'
            });
        }
    } catch (error) {
        return 'Fecha desconocida';
    }
}

async function loadMultiChainTransactionHistory() {
    console.log('Cargando historial de transacciones multi-red...');
    try {
        showTransactionLoadingState(true);
        const transactionPromises = [];
        const networks = ['BSC', 'ETH'];
        
        for (const network of networks) {
            if (appState.wallets[network]) {
                transactionPromises.push(
                    loadNetworkTransactionHistory(network)
                        .then(result => result)
                        .catch(error => [])
                );
            }
        }
        
        const results = await Promise.allSettled(transactionPromises);
        const allTransactions = [];
        
        results.forEach((result, index) => {
            if (result.status === 'fulfilled') {
                allTransactions.push(...result.value);
            }
        });
        
        allTransactions.sort((a, b) => {
            const timeA = parseInt(a.timeStamp) || 0;
            const timeB = parseInt(b.timeStamp) || 0;
            return timeB - timeA;
        });
        
        appState.transactionState.allTransactions = allTransactions;
        applySimpleFilters();
        
        if (allTransactions.length > 0) {
            showToast(`✅ ${allTransactions.length} transacciones cargadas`, 'success');
        } else {
            showToast('📭 No se encontraron transacciones', 'info');
        }
    } catch (error) {
        console.error('Error cargando historial multi-red:', error);
        showToast('Error cargando historial de transacciones', 'error');
    } finally {
        showTransactionLoadingState(false);
    }
}

function applyMultiChainTransactionFilter() {
    let filtered = [...appState.transactionState.allTransactions];
    
    if (appState.transactionState.networkFilter !== 'all') {
        filtered = filtered.filter(tx => tx.network === appState.transactionState.networkFilter);
    }
    
    switch (appState.transactionState.currentFilter) {
        case 'received':
            filtered = filtered.filter(tx => tx.isIncoming);
            break;
        case 'sent':
            filtered = filtered.filter(tx => !tx.isIncoming);
            break;
    }
    
    appState.transactionState.filteredTransactions = filtered;
    appState.transactionState.totalPages = Math.ceil(filtered.length / appState.transactionState.itemsPerPage);
    displayCurrentPage();
    updateTransactionCount();
}


function initializeNetworkFilters() {
    const networkButtons = document.querySelectorAll('.filter-btn[data-network]');
    
    networkButtons.forEach(btn => {
        btn.addEventListener('click', function() {
            networkButtons.forEach(b => b.classList.remove('active'));
            this.classList.add('active');
            
            const network = this.getAttribute('data-network');
            appState.transactionState.networkFilter = network;
            appState.transactionState.currentPage = 1;
            
           applySimpleFilters();
            updatePagination();
            updateFilterCounts();
        });
    });
}

function initializeTypeFilters() {
    const typeButtons = document.querySelectorAll('.filter-btn[data-type]');
    
    typeButtons.forEach(btn => {
        btn.addEventListener('click', function() {
            typeButtons.forEach(b => b.classList.remove('active'));
            this.classList.add('active');
            
            const type = this.getAttribute('data-type');
            appState.transactionState.typeFilter = type;
            appState.transactionState.currentPage = 1;
            
            console.log(`📊 Filtro de tipo cambiado a: ${type}`);
            applySimpleFilters();
            updatePagination();
            updateFilterCounts();
        });
    });
    
    console.log('✅ Filtros de tipo inicializados');
}


function displayCurrentPage() {
    const startIndex = (appState.transactionState.currentPage - 1) * appState.transactionState.itemsPerPage;
    const endIndex = startIndex + appState.transactionState.itemsPerPage;
    const pageTransactions = appState.transactionState.filteredTransactions.slice(startIndex, endIndex);
    
    displayTransactions(pageTransactions);
}

function updateTransactionCount() {
    const countElement = document.getElementById('transactionCount');
    const total = appState.transactionState.filteredTransactions.length;
    const showing = Math.min(total, appState.transactionState.itemsPerPage);
    const totalAll = appState.transactionState.allTransactions.length;
    
    if (countElement) {
        const filteredCount = document.getElementById('filteredCount');
        const totalCount = document.getElementById('totalCount');
        
        if (filteredCount) filteredCount.textContent = total;
        if (totalCount) totalCount.textContent = totalAll;
        
        if (appState.transactionState.totalPages > 1) {
            countElement.textContent = `Mostrando ${showing} de ${total} transacciones`;
        } else {
            countElement.textContent = `${total} transacción${total !== 1 ? 'es' : ''}`;
        }
    }
}

function getCurrentWalletAddress(network) {
    return appState.wallets[network] ? appState.wallets[network].address.toLowerCase() : '';
}

async function showTransactionDetails(hash, network) {
    try {
        let txDetails;
        if (network === 'BSC' || network === 'ETH') {
            const provider = appState.providers[network];
            const tx = await provider.getTransaction(hash);
            const receipt = await provider.getTransactionReceipt(hash);
            txDetails = {
                hash: hash,
                from: tx.from,
                to: tx.to,
                value: ethers.utils.formatEther(tx.value),
                gasUsed: receipt?.gasUsed?.toString() || 'N/A',
                gasPrice: ethers.utils.formatUnits(tx.gasPrice, 'gwei'),
                blockNumber: tx.blockNumber,
                network: network,
                status: receipt?.status === 1 ? 'Confirmada' : receipt?.status === 0 ? 'Fallida' : 'Pendiente',
                timestamp: new Date().toLocaleString()
            };
        } 
        
        const modalContent = document.getElementById('transactionDetailsContent');
        modalContent.innerHTML = `
            <div class="transaction-details">
                <div class="detail-item">
                    <strong>Hash:</strong> <span class="detail-value">${txDetails.hash}</span>
                </div>
                <div class="detail-item">
                    <strong>Red:</strong> <span class="detail-value">${txDetails.network}</span>
                </div>
                <div class="detail-item">
                    <strong>De:</strong> <span class="detail-value">${txDetails.from || 'N/A'}</span>
                </div>
                <div class="detail-item">
                    <strong>Para:</strong> <span class="detail-value">${txDetails.to || 'N/A'}</span>
                </div>
                <div class="detail-item">
                    <strong>Valor:</strong> <span class="detail-value">${txDetails.value} ${MULTICHAIN_CONFIG[network].TOKENS.NATIVE}</span>
                </div>
                <div class="detail-item">
                    <strong>Gas Usado:</strong> <span class="detail-value">${txDetails.gasUsed}</span>
                </div>
                <div class="detail-item">
                    <strong>Precio Gas:</strong> <span class="detail-value">${txDetails.gasPrice} Gwei</span>
                </div>
                <div class="detail-item">
                    <strong>Estado:</strong> <span class="detail-value ${txDetails.status === 'Confirmada' ? 'success' : 'danger'}">${txDetails.status}</span>
                </div>
            </div>
        `;
        showModal('transactionDetailsModal');
    } catch (error) {
        console.error('Error obteniendo detalles de transaccion:', error);
        showToast('Error cargando detalles de transaccion', 'error');
    }
}

function updateTransactionHistoryUI() {
    applyMultiChainTransactionFilter();
    updatePagination();
}

function showTransactionLoadingState(show) {
    const container = document.getElementById('transactionHistory');
    if (show) {
        container.innerHTML = `
            <div class="no-transactions">
                <i class="fas fa-spinner fa-spin"></i>
                <h4>Cargando transacciones...</h4>
                <p>Por favor espera</p>
            </div>
        `;
    }
}

function displayNoTransactions() {
    const container = document.getElementById('transactionHistory');
    container.innerHTML = `
        <div class="no-transactions">
            <i class="fas fa-exchange-alt"></i>
            <h4>No hay transacciones para mostrar</h4>
            <p>Realiza tu primera transaccion para ver el historial</p>
        </div>
    `;
}



function updatePagination() {
    const pagination = document.getElementById('transactionPagination');
    const prevBtn = document.getElementById('prevPageBtn');
    const nextBtn = document.getElementById('nextPageBtn');
    const pageInfo = document.getElementById('pageInfo');
    
    if (appState.transactionState.filteredTransactions.length > appState.transactionState.itemsPerPage) {
        pagination.classList.remove('hidden');
    } else {
        pagination.classList.add('hidden');
    }
    
    prevBtn.disabled = appState.transactionState.currentPage === 1;
    nextBtn.disabled = appState.transactionState.currentPage === appState.transactionState.totalPages;
    pageInfo.textContent = `Pagina ${appState.transactionState.currentPage} de ${appState.transactionState.totalPages}`;
}

function goToPreviousPage() {
    if (appState.transactionState.currentPage > 1) {
        appState.transactionState.currentPage--;
        displayCurrentPage();
        updatePagination();
    }
}

function goToNextPage() {
    if (appState.transactionState.currentPage < appState.transactionState.totalPages) {
        appState.transactionState.currentPage++;
        displayCurrentPage();
        updatePagination();
    }
}

function saveWalletDataToStorage(network, walletData) {
    try {
        const existingData = getWalletDataFromStorage('all') || {};
        existingData[network] = walletData;
        localStorage.setItem(MULTICHAIN_CONFIG.STORAGE_KEYS.WALLETS, JSON.stringify(existingData));
    } catch (error) {
        console.error(`Error guardando wallet ${network}:`, error);
    }
}

function getWalletDataFromStorage(network) {
    try {
        const data = localStorage.getItem(MULTICHAIN_CONFIG.STORAGE_KEYS.WALLETS);
        if (!data) return null;
        const allData = JSON.parse(data);
        return network === 'all' ? allData : allData[network];
    } catch (error) {
        console.error('Error obteniendo datos de wallet:', error);
        return null;
    }
}

async function saveMultiChainAppState() {
    try {
        const appStateData = {
            wallets: {},
            cache: appState.cache,
            prices: appState.prices,
            gasPrices: appState.gasPrices,
            transactionState: appState.transactionState,
            metadata: {
                savedAt: Date.now(),
                version: '5.0',
                connectedNetworks: getConnectedNetworks(),
                lastSync: new Date().toISOString()
            }
        };
        
        Object.keys(appState.wallets).forEach(network => {
            if (appState.wallets[network]) {
                appStateData.wallets[network] = {
                    address: appState.wallets[network].address,
                    network: network,
                    isConnected: true
                };
            }
        });
        
        localStorage.setItem(MULTICHAIN_CONFIG.STORAGE_KEYS.APP_STATE, JSON.stringify(appStateData));
        return true;
    } catch (error) {
        console.error('Error guardando estado multi-red:', error);
        return false;
    }
}

async function loadMultiChainAppState() {
    try {
        const stored = localStorage.getItem(MULTICHAIN_CONFIG.STORAGE_KEYS.APP_STATE);
        if (!stored) return false;
        const appStateData = JSON.parse(stored);
        const now = Date.now();
        const savedAt = appStateData.metadata?.savedAt || 0;
        const maxAge = 24 * 60 * 60 * 1000;
        
        if ((now - savedAt) > maxAge) {
            localStorage.removeItem(MULTICHAIN_CONFIG.STORAGE_KEYS.APP_STATE);
            return false;
        }
        
        if (appStateData.cache) appState.cache = appStateData.cache;
        if (appStateData.prices) appState.prices = appStateData.prices;
        if (appStateData.gasPrices) appState.gasPrices = appStateData.gasPrices;
        if (appStateData.transactionState) appState.transactionState = appStateData.transactionState;
        
        if (appStateData.wallets) {
            for (const [network, walletInfo] of Object.entries(appStateData.wallets)) {
                if (walletInfo.isConnected) {
                    const walletData = getWalletDataFromStorage(network);
                    if (walletData) {
                        await connectWalletFromStorage(network, walletData);
                    }
                }
            }
        }
        return true;
    } catch (error) {
        console.error('Error cargando estado multi-red:', error);
        localStorage.removeItem(MULTICHAIN_CONFIG.STORAGE_KEYS.APP_STATE);
        return false;
    }
}

function getConnectedNetworks() {
    return Object.keys(appState.wallets).filter(network => appState.wallets[network] !== null);
}

function getWalletAddress(network) {
    return appState.wallets[network] ? appState.wallets[network].address : 'No conectada';
}

function getNetworkIcon(network) {
    const icons = {
        'BSC': 'fa-brands fa-b',
        'ETH': 'fa-brands fa-ethereum',
    };
    return icons[network] || 'fa-solid fa-wallet';
}

function getSupportedTokensForNetwork(network) {
    const config = MULTICHAIN_CONFIG[network];
    return [config.TOKENS.NATIVE, 'USDT'];
}

function copyToClipboard(text) {
    if (!text) {
        showToast('No hay texto para copiar', 'error');
        return;
    }
    
    if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard.writeText(text).then(() => {
            showToast('Copiado al portapapeles', 'success');
        }).catch(err => {
            fallbackCopyToClipboard(text);
        });
    } else {
        fallbackCopyToClipboard(text);
    }
}

function fallbackCopyToClipboard(text) {
    const textArea = document.createElement('textarea');
    textArea.value = text;
    textArea.style.position = 'fixed';
    textArea.style.left = '-999999px';
    textArea.style.top = '-999999px';
    textArea.style.opacity = '0';
    document.body.appendChild(textArea);
    
    try {
        textArea.focus();
        textArea.select();
        textArea.setSelectionRange(0, 99999);
        const successful = document.execCommand('copy');
        document.body.removeChild(textArea);
        if (successful) {
            showToast('Copiado al portapapeles', 'success');
        } else {
            showToast('Error al copiar. Intenta manualmente.', 'error');
        }
    } catch (err) {
        document.body.removeChild(textArea);
        showToast('Error al copiar: ' + err.message, 'error');
    }
}

function toggleLoading(buttonId, show) {
    const textElement = document.getElementById(`${buttonId}Text`);
    const loadingElement = document.getElementById(`${buttonId}Loading`);
    if (textElement && loadingElement) {
        if (show) {
            textElement.classList.add('hidden');
            loadingElement.classList.remove('hidden');
        } else {
            textElement.classList.remove('hidden');
            loadingElement.classList.add('hidden');
        }
    }
}

function showModal(modalId) {
    const modal = document.getElementById(modalId);
    if (modal) {
        modal.classList.add('active');
        document.body.style.overflow = 'hidden';
    }
}

function hideModal(modalId) {
    const modal = document.getElementById(modalId);
    if (modal) {
        modal.classList.remove('active');
        document.body.style.overflow = 'auto';
    }
}

function hideSendModal() { hideModal('sendModal'); }
function hideReceiveModal() { hideModal('receiveModal'); }
function hideBackupModal() { hideModal('backupModal'); }
function hideImportModal() { hideModal('importWalletModal'); }

function showToast(message, type = 'info') {
    const toast = document.createElement('div');
    toast.className = `toast ${type}`;
    toast.innerHTML = `
        <div class="flex items-center">
            <i class="fas ${getToastIcon(type)} toast-icon"></i>
            <span>${message}</span>
        </div>
    `;
    document.getElementById('toastContainer').appendChild(toast);
    setTimeout(() => {
        toast.classList.add('fade-out');
        setTimeout(() => toast.remove(), 300);
    }, 3000);
}

function getToastIcon(type) {
    const icons = {
        success: 'fa-check-circle',
        error: 'fa-exclamation-circle',
        warning: 'fa-exclamation-triangle',
        info: 'fa-info-circle'
    };
    return icons[type] || 'fa-info-circle';
}

function handleOnlineStatus() {
    appState.connectionStatus.online = true;
    showToast('Conexion restaurada - Sincronizando...', 'success');
    updateConnectionStatus();
    setTimeout(async () => {
        await syncAllMultiChainData();
    }, 1000);
}

function handleOfflineStatus() {
    appState.connectionStatus.online = false;
    showToast('Modo offline - Usando cache local', 'warning');
    updateConnectionStatus();
    saveMultiChainAppState();
}

async function loadOfflineMultiChainData() {
    updateMultiChainDashboard();
    showToast('Datos cargados desde cache (modo offline)', 'info');
}

async function syncAllMultiChainData() {
    if (!appState.connectionStatus.online) return;
    try {
        await Promise.allSettled([
            loadPrices(),
            loadMultiChainBalances(),
            loadMultiChainTransactionHistory()
        ]);
        await saveMultiChainAppState();
    } catch (error) {
        console.error('Error en sincronizacion multi-red:', error);
    }
}

function setupMultiChainAutoUpdates() {
    setInterval(() => {
        if (appState.connectionStatus.online && getConnectedNetworks().length > 0) {
            loadPrices();
        }
    }, MULTICHAIN_CONFIG.UPDATE_INTERVALS.PRICES);
    
    setInterval(() => {
        if (appState.connectionStatus.online && getConnectedNetworks().length > 0) {
            loadMultiChainBalances();
        }
    }, MULTICHAIN_CONFIG.UPDATE_INTERVALS.BALANCES);
    
    setInterval(() => {
        if (appState.connectionStatus.online && getConnectedNetworks().length > 0) {
            loadAllGasPrices();
        }
    }, 60000);
    
    setInterval(() => {
        if (appState.connectionStatus.online && getConnectedNetworks().length > 0) {
            syncAllMultiChainData();
        }
    }, MULTICHAIN_CONFIG.UPDATE_INTERVALS.SYNC);
}

async function createWalletForNetwork(network, mnemonic, index = 0) {
    try {
        let wallet;
        if (network === 'BSC' || network === 'ETH') {
            wallet = ethers.Wallet.fromMnemonic(mnemonic, MULTICHAIN_CONFIG[network].DERIVATION_PATH);
            if (!wallet || !wallet.address || !wallet.privateKey) {
                throw new Error(`Wallet ${network} invalida`);
            }
            if (!ethers.utils.isAddress(wallet.address)) {
                throw new Error(`Direccion ${network} invalida`);
            }
            wallet = wallet.connect(appState.providers[network]);
        } else {
            throw new Error(`Red no soportada: ${network}`);
        }
        return wallet;
    } catch (error) {
        console.error(`Error creando wallet ${network}:`, error);
        throw error;
    }
}



function integrateAdvancedFilters() {
    // Agregar HTML para filtros avanzados
    const transactionSection = document.querySelector('#transactionHistory').parentElement;
    const existingTabs = transactionSection.querySelector('.transaction-tabs');
    
    if (existingTabs) {
        const advancedFiltersHTML = `
            <div class="advanced-filters mb-4">
                <div class="filter-group">
                    <label class="filter-label">Filtros Avanzados:</label>
                    <div class="filter-buttons">
                        <button class="filter-btn" data-type="token">
                            <i class="fas fa-coins"></i>Tokens
                            <span class="filter-badge">0</span>
                        </button>
                        <button class="filter-btn" data-type="native">
                            <i class="fas fa-ethereum"></i>Nativas
                            <span class="filter-badge">0</span>
                        </button>
                        <button class="filter-btn" data-date="today">
                            <i class="fas fa-calendar-day"></i>Hoy
                            <span class="filter-badge">0</span>
                        </button>
                        <button class="filter-btn" data-date="week">
                            <i class="fas fa-calendar-week"></i>Esta semana
                            <span class="filter-badge">0</span>
                        </button>
                        <button class="filter-btn" data-amount="large">
                            <i class="fas fa-money-bill-wave"></i>Grandes
                            <span class="filter-badge">0</span>
                        </button>
                    </div>
                </div>
            </div>
        `;
        
        existingTabs.insertAdjacentHTML('afterend', advancedFiltersHTML);
    }
    
    // Inicializar filtros avanzados
}

// ACTUALIZAR el objeto appState.defi
appState.defi = {
    venus: { 
        usdtBalance: '0', 
        apy: '0',
        lastUpdate: 0,
        earnings: '0'
    },
    aave: { 
        usdtBalance: '0', 
        apy: '0',
        lastUpdate: 0,
        earnings: '0'
    },
    compound: {
        usdcBalance: '0',
        apy: '0',
        lastUpdate: 0,
        earnings: '0',
        network: 'ETH' // Por defecto Ethereum
    },
    apyCache: {
        venus: { data: null, timestamp: 0 },
        aave: { data: null, timestamp: 0 },
        compound: { data: null, timestamp: 0 }
    }
};

// REEMPLAZAR el AAVE_ABI con uno correcto
const AAVE_ABI = [
    {
        "inputs": [
            {"internalType": "address", "name": "asset", "type": "address"}
        ],
        "name": "getReserveData",
        "outputs": [
            {
                "components": [
                    {"internalType": "uint256", "name": "configuration", "type": "uint256"},
                    {"internalType": "uint128", "name": "liquidityIndex", "type": "uint128"},
                    {"internalType": "uint128", "name": "variableBorrowIndex", "type": "uint128"},
                    {"internalType": "uint128", "name": "currentLiquidityRate", "type": "uint128"},
                    {"internalType": "uint128", "name": "currentVariableBorrowRate", "type": "uint128"},
                    {"internalType": "uint128", "name": "currentStableBorrowRate", "type": "uint128"},
                    {"internalType": "uint40", "name": "lastUpdateTimestamp", "type": "uint40"},
                    {"internalType": "address", "name": "aTokenAddress", "type": "address"},
                    {"internalType": "address", "name": "stableDebtTokenAddress", "type": "address"},
                    {"internalType": "address", "name": "variableDebtTokenAddress", "type": "address"},
                    {"internalType": "address", "name": "interestRateStrategyAddress", "type": "address"},
                    {"internalType": "uint8", "name": "id", "type": "uint8"}
                ],
                "internalType": "struct DataTypes.ReserveData",
                "name": "",
                "type": "tuple"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    "function supply(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external",
    "function withdraw(address asset, uint256 amount, address to) external returns (uint256)"
];

// REEMPLAZAR updateAaveApy() con esta versión mejorada
async function updateAaveApy() {
    try {
        console.log('🔄 Obteniendo APY REAL de Aave V3...');
        
        const cacheKey = 'aave_apy_real';
        const cached = getCachedData(cacheKey, 120000);
        
        if (cached && cached.source === 'aave_api') {
            updateAaveApyDisplay(cached);
            return;
        }

        // Método 1: API oficial de Aave
        let apyData = await fetchAaveApyFromAPI();
        
        if (!apyData) {
            // Método 2: Contrato directo
            apyData = await fetchAaveApyFromContract();
        }
        
        if (!apyData) {
            // Método 3: API de DefiLlama
            apyData = await fetchAaveApyFromDefiLlama();
        }

        if (apyData) {
            setCachedData(cacheKey, apyData);
            updateAaveApyDisplay(apyData);
        } else {
            throw new Error('Todos los métodos fallaron');
        }
        
    } catch (error) {
        console.error('❌ Error crítico actualizando APY Aave:', error);
        document.getElementById('aaveApyStatus').textContent = '❌ Error conexión';
        document.getElementById('aaveUsdtApy').textContent = '-';
    }
}

// Método 1: API oficial de Aave
async function fetchAaveApyFromAPI() {
    try {
        const response = await fetch('https://aave-api-v2.aave.com/data/rates');
        const data = await response.json();
        
        const usdtData = data.find(item => 
            item.symbol === 'USDT' && 
            item.network === 'ethereum' &&
            item.platform === 'aave-v3'
        );
        
        if (usdtData && usdtData.apy) {
            return {
                usdt: parseFloat(usdtData.apy).toFixed(2),
                timestamp: Date.now(),
                source: 'aave_api',
                network: 'ETH',
                rawData: usdtData
            };
        }
    } catch (error) {
        console.warn('API Aave falló:', error);
    }
    return null;
}

// Método 2: Contrato directo Aave V3
async function fetchAaveApyFromContract() {
    try {
        const aavePool = new ethers.Contract(
            DEFI_CONFIG.AAVE_ETH.POOL,
            [
                "function getReserveData(address asset) view returns ((uint256,uint128,uint128,uint128,uint128,uint128,uint40,address,address,address,address,uint8))"
            ],
            appState.providers.ETH
        );

        const reserveData = await aavePool.getReserveData(MULTICHAIN_CONFIG.ETH.TOKENS.USDT.CONTRACT);
        
        // currentLiquidityRate está en la posición 3 (índice 3)
        const liquidityRate = reserveData[3];
        const apy = calculateAaveApyFromRate(liquidityRate);
        
        return {
            usdt: apy.toFixed(2),
            timestamp: Date.now(),
            source: 'aave_blockchain',
            network: 'ETH',
            rawRate: liquidityRate.toString()
        };
    } catch (error) {
        console.warn('Contrato Aave falló:', error);
        return null;
    }
}

// Método 3: DefiLlama como respaldo
async function fetchAaveApyFromDefiLlama() {
    try {
        const response = await fetch('https://yields.llama.fi/pools');
        const data = await response.json();
        
        const aavePool = data.data.find(pool => 
            pool.project === 'aave-v3' && 
            pool.symbol === 'USDT' &&
            pool.chain === 'Ethereum'
        );
        
        if (aavePool && aavePool.apy) {
            return {
                usdt: parseFloat(aavePool.apy).toFixed(2),
                timestamp: Date.now(),
                source: 'defillama',
                network: 'ETH'
            };
        }
    } catch (error) {
        console.warn('DefiLlama falló:', error);
    }
    return null;
}
// REEMPLAZAR esta función - VERSIÓN CORREGIDA
function calculateAaveApyFromRate(liquidityRate) {
    try {
        console.log('🧮 Calculando APY Aave desde tasa:', liquidityRate.toString());
        
        // Aave rates están en ray (27 decimales)
        const RAY = ethers.BigNumber.from(10).pow(27);
        const SECONDS_PER_YEAR = 31536000;
        
        // Convertir BigNumber a número para cálculo
        const ratePerSecond = Number(liquidityRate) / Number(RAY);
        
        console.log('📊 Tasa por segundo:', ratePerSecond);
        
        // Validar que la tasa sea válida
        if (isNaN(ratePerSecond) || !isFinite(ratePerSecond) || ratePerSecond <= 0) {
            console.warn('⚠️ Tasa Aave inválida, usando valor por defecto');
            return 3.25; // Valor por defecto seguro
        }
        
        // Fórmula APY: (1 + r/n)^n - 1
        // Para Aave: APY = (1 + ratePerSecond)^secondsPerYear - 1
        const apy = (Math.pow(1 + ratePerSecond, SECONDS_PER_YEAR) - 1) * 100;
        
        console.log('🎯 APY calculado:', apy);
        
        // Validar resultado
        if (isNaN(apy) || !isFinite(apy) || apy < 0) {
            console.warn('⚠️ APY calculado inválido, usando valor por defecto');
            return 3.25;
        }
        
        // Limitar a un máximo razonable (1000% = 1000)
        const finalApy = Math.min(Math.max(apy, 0.1), 1000);
        
        console.log('✅ APY final Aave:', finalApy);
        return finalApy;
        
    } catch (error) {
        console.error('❌ Error crítico calculando APY Aave:', error);
        return 3.25; // Valor por defecto seguro
    }
}

function calculateAaveApy(liquidityRate) {
    try {
        const RAY = ethers.BigNumber.from(10).pow(27);
        const SECONDS_PER_YEAR = 31536000;
        
        // Convertir de ray a tasa anual
        const ratePerSecond = liquidityRate.div(RAY);
        const ratePerYear = ratePerSecond.mul(SECONDS_PER_YEAR);
        
        // Convertir a porcentaje (APY)
        const apy = (ratePerYear.toNumber() / 1e27) * 100;
        
        console.log('🧮 Cálculo APY Aave:', {
            liquidityRate: liquidityRate.toString(),
            ratePerSecond: ratePerSecond.toString(),
            apy: apy
        });
        
        return Math.max(apy, 0.1); // Mínimo 0.1%
    } catch (error) {
        console.error('Error calculando APY Aave:', error);
        return 3.25; // Valor por defecto
    }
}
// En la función depositToVenus - REEMPLAZAR con esta versión corregida
async function depositToVenus() {
    try {
        const amount = document.getElementById('venusDepositAmount').value;
        if (!amount || parseFloat(amount) <= 0) {
            showToast('Ingresa una cantidad válida', 'error');
            return;
        }

        toggleLoading('venusDeposit', true);
        showToast('⏳ Iniciando depósito en Venus...', 'info');
        
        const network = 'BSC';
        const wallet = appState.wallets[network];
        
        if (!wallet) {
            throw new Error('Wallet BSC no conectada');
        }

        // ✅ FORZAR 1 GWEI FIJO
        const gasPrice = ethers.utils.parseUnits("1", "gwei");
        
        // 1. APPROVE USDT con 1 Gwei
        const usdtContract = new ethers.Contract(
            MULTICHAIN_CONFIG.BSC.TOKENS.USDT.CONTRACT,
            USDT_ABI,
            wallet
        );
        
        const amountWei = ethers.utils.parseUnits(amount, 18);
        
        // Verificar balance REAL
        const balance = await usdtContract.balanceOf(wallet.address);
        if (balance.lt(amountWei)) {
            throw new Error(`Saldo insuficiente. Disponible: ${ethers.utils.formatUnits(balance, 18)} USDT`);
        }

        showToast('⏳ Aprobando USDT...', 'info');
        const approveTx = await usdtContract.approve(
            DEFI_CONFIG.VENUS_BSC.VUSDT, 
            amountWei,
            {
                gasPrice: gasPrice, // ← 1 Gwei FIJO
                gasLimit: 50000
            }
        );
        await approveTx.wait();
        
        // 2. DEPOSITAR en Venus con 1 Gwei
        const venusContract = new ethers.Contract(
            DEFI_CONFIG.VENUS_BSC.VUSDT,
            VENUS_ABI,
            wallet
        );
        
        showToast('⏳ Depositando en Venus...', 'info');
        const depositTx = await venusContract.mint(amountWei, {
            gasPrice: gasPrice, // ← 1 Gwei FIJO
            gasLimit: 200000
        });
        
        const receipt = await depositTx.wait();
        
        showToast('✅ Depósito exitoso en Venus', 'success');
        
        // Limpiar input y actualizar
        document.getElementById('venusDepositAmount').value = '';
        await updateVenusBalances();
        await loadNetworkBalances('BSC');
        
    } catch (error) {
        console.error('Error en depósito Venus:', error);
        showToast('Error en depósito Venus: ' + error.message, 'error');
    } finally {
        toggleLoading('venusDeposit', false);
    }
}
// REEMPLAZAR la función depositToAave con esta versión corregida
async function depositToAave() {
    try {
        const amountInput = document.getElementById('aaveDepositAmount');
        const amount = amountInput?.value;
        
        if (!amount || parseFloat(amount) <= 0) {
            showToast('❌ Ingresa una cantidad válida', 'error');
            return;
        }

        toggleLoading('aaveDeposit', true);
        showToast('⏳ Iniciando depósito REAL en Aave...', 'info');
        
        const network = 'ETH';
        const wallet = appState.wallets[network];
        
        if (!wallet) {
            throw new Error('Wallet ETH no conectada');
        }

        // ✅ FORZAR 1 GWEI FIJO para ETH también
        const gasPrice = ethers.utils.parseUnits("1", "gwei");

        // 1. CONTRATO USDT Ethereum
        const usdtContract = new ethers.Contract(
            MULTICHAIN_CONFIG.ETH.TOKENS.USDT.CONTRACT,
            USDT_ABI,
            wallet
        );
        
        const amountWei = ethers.utils.parseUnits(amount, 6); // USDT en ETH tiene 6 decimales
        
        // Verificar balance REAL
        const balance = await usdtContract.balanceOf(wallet.address);
        if (balance.lt(amountWei)) {
            throw new Error(`Saldo insuficiente. Disponible: ${ethers.utils.formatUnits(balance, 6)} USDT`);
        }

        // 2. APPROVE REAL para Aave con 1 Gwei
        showToast('⏳ Aprobando USDT para Aave...', 'info');
        const approveTx = await usdtContract.approve(
            DEFI_CONFIG.AAVE_ETH.POOL, 
            amountWei,
            {
                gasPrice: gasPrice, // ← 1 Gwei FIJO
                gasLimit: 100000
            }
        );
        
        await approveTx.wait();
        showToast('✅ Aprobación confirmada', 'success');

        // 3. DEPÓSITO REAL en Aave con 1 Gwei
        const aavePool = new ethers.Contract(
            DEFI_CONFIG.AAVE_ETH.POOL,
            AAVE_ABI,
            wallet
        );
        
        showToast('⏳ Depositando en Aave V3...', 'info');
        const depositTx = await aavePool.supply(
            MULTICHAIN_CONFIG.ETH.TOKENS.USDT.CONTRACT,
            amountWei,
            wallet.address,
            0, // referralCode
            {
                gasPrice: gasPrice, // ← 1 Gwei FIJO
                gasLimit: 300000
            }
        );
        
        const receipt = await depositTx.wait();
        
        showToast('✅ Depósito REAL exitoso en Aave V3', 'success');
        
        // Actualizar balances
        document.getElementById('aaveDepositAmount').value = '';
        await updateAaveBalances();
        await loadNetworkBalances('ETH');
        
    } catch (error) {
        console.error('❌ Error en depósito REAL Aave:', error);
        showToast(`Error: ${error.message}`, 'error');
    } finally {
        toggleLoading('aaveDeposit', false);
    }
}

// REEMPLAZAR las funciones de retiro con estas versiones corregidas
async function withdrawFromVenus() {
    try {
        toggleLoading('venusWithdraw', true);
        showToast('⏳ Iniciando retiro REAL de Venus...', 'info');
        
        const network = 'BSC';
        const wallet = appState.wallets[network];
        
        if (!wallet) {
            throw new Error('Wallet BSC no conectada');
        }

        // ✅ FORZAR 1 GWEI FIJO
        const gasPrice = ethers.utils.parseUnits("1", "gwei");

        const venusContract = new ethers.Contract(
            DEFI_CONFIG.VENUS_BSC.VUSDT,
            VENUS_ABI,
            wallet
        );
        
        // Obtener balance REAL de vTokens
        const vTokenBalance = await venusContract.balanceOf(wallet.address);
        
        if (vTokenBalance.eq(0)) {
            showToast('❌ No tienes fondos en Venus', 'warning');
            return;
        }

        showToast('⏳ Retirando de Venus...', 'info');
        
        // RETIRO REAL - redeem todos los vTokens con 1 Gwei
        const withdrawTx = await venusContract.redeem(vTokenBalance, {
            gasPrice: gasPrice, // ← 1 Gwei FIJO
            gasLimit: 300000
        });
        
        const receipt = await withdrawTx.wait();
        
        showToast('✅ Retiro REAL exitoso de Venus', 'success');
        
        // Actualizar balances
        await updateVenusBalances();
        await loadNetworkBalances('BSC');
        
    } catch (error) {
        console.error('❌ Error en retiro REAL Venus:', error);
        showToast(`Error: ${error.message}`, 'error');
    } finally {
        toggleLoading('venusWithdraw', false);
    }
}

async function withdrawFromAave() {
    try {
        toggleLoading('aaveWithdraw', true);
        showToast('⏳ Iniciando retiro REAL de Aave...', 'info');
        
        const network = 'ETH';
        const wallet = appState.wallets[network];
        
        if (!wallet) {
            throw new Error('Wallet ETH no conectada');
        }

        // ✅ FORZAR 1 GWEI FIJO
        const gasPrice = ethers.utils.parseUnits("1", "gwei");

        const aavePool = new ethers.Contract(
            DEFI_CONFIG.AAVE_ETH.POOL,
            AAVE_ABI,
            wallet
        );
        
        // Obtener balance REAL en Aave
        const aUSDTContract = new ethers.Contract(
            DEFI_CONFIG.AAVE_ETH.AUSDT,
            [
                "function balanceOf(address) view returns (uint256)",
                "function decimals() view returns (uint8)"
            ],
            wallet
        );
        
        const aTokenBalance = await aUSDTContract.balanceOf(wallet.address);
        
        if (aTokenBalance.eq(0)) {
            showToast('❌ No tienes fondos en Aave', 'warning');
            return;
        }

        showToast('⏳ Retirando de Aave...', 'info');
        
        // RETIRO REAL - withdraw máximo con 1 Gwei
        const withdrawTx = await aavePool.withdraw(
            MULTICHAIN_CONFIG.ETH.TOKENS.USDT.CONTRACT,
            aTokenBalance, // Retirar todo
            wallet.address,
            {
                gasPrice: gasPrice, // ← 1 Gwei FIJO
                gasLimit: 300000
            }
        );
        
        const receipt = await withdrawTx.wait();
        
        showToast('✅ Retiro REAL exitoso de Aave', 'success');
        
        // Actualizar balances
        await updateAaveBalances();
        await loadNetworkBalances('ETH');
        
    } catch (error) {
        console.error('❌ Error en retiro REAL Aave:', error);
        showToast(`Error: ${error.message}`, 'error');
    } finally {
        toggleLoading('aaveWithdraw', false);
    }
}
// ==================== BALANCES REALES VENUS ====================
async function updateVenusBalances() {
    if (!appState.wallets.BSC) {
        console.log('❌ Wallet BSC no conectada para Venus');
        return;
    }
    
    try {
        console.log('🔄 Actualizando balances REALES Venus...');
        const venusContract = new ethers.Contract(
            DEFI_CONFIG.VENUS_BSC.VUSDT,
            VENUS_ABI,
            appState.providers.BSC
        );
        
        const wallet = appState.wallets.BSC;
        const vTokenBalance = await venusContract.balanceOf(wallet.address);
        
        console.log('📊 Balance vToken REAL Venus:', vTokenBalance.toString());
        
        if (vTokenBalance.gt(0)) {
            // Calcular balance subyacente REAL
            const exchangeRate = await venusContract.exchangeRateCurrent();
            const underlyingBalance = vTokenBalance.mul(exchangeRate).div(ethers.constants.WeiPerEther);
            const usdtBalance = ethers.utils.formatUnits(underlyingBalance, 18);
            
            console.log('💰 Balance USDT REAL Venus:', usdtBalance);
            
            appState.defi.venus.usdtBalance = usdtBalance;
            document.getElementById('venusUsdtBalance').textContent = `${parseFloat(usdtBalance).toFixed(2)} USDT`;
            
            // Calcular rendimientos REALES estimados
            const apy = parseFloat(appState.defi.venus.apy || '4.25');
            const dailyEarnings = (parseFloat(usdtBalance) * apy / 100 / 365).toFixed(4);
            document.getElementById('venusEarnings').textContent = `$${dailyEarnings}`;
        } else {
            appState.defi.venus.usdtBalance = '0';
            document.getElementById('venusUsdtBalance').textContent = '0 USDT';
            document.getElementById('venusEarnings').textContent = '$0.00';
        }
        
        // Actualizar balance disponible en wallet
        await loadNetworkBalances('BSC');
        const walletBalance = appState.cache.balances.BSC?.data?.usdt || '0';
        document.getElementById('venusAvailableUsdt').textContent = `${parseFloat(walletBalance).toFixed(2)} USDT`;
        document.getElementById('venusWalletBalance').textContent = `${parseFloat(walletBalance).toFixed(2)} USDT`;
        
        console.log('✅ Balances REALES Venus actualizados');
        
    } catch (error) {
        console.error('❌ Error actualizando balances REALES Venus:', error);
        document.getElementById('venusUsdtBalance').textContent = 'Error';
        document.getElementById('venusEarnings').textContent = '$0.00';
    }
}

// En updateAaveBalances, agregar validación:
async function updateAaveBalances() {
    if (!appState.wallets.ETH) {
        console.log('❌ Wallet ETH no conectada para Aave');
        return;
    }
    
    try {
        console.log('🔄 Actualizando balances REALES Aave...');
        const aUSDTContract = new ethers.Contract(
            DEFI_CONFIG.AAVE_ETH.AUSDT,
            [
                "function balanceOf(address) view returns (uint256)",
                "function decimals() view returns (uint8)"
            ],
            appState.providers.ETH
        );
        
        const wallet = appState.wallets.ETH;
        const aTokenBalance = await aUSDTContract.balanceOf(wallet.address);
        
        console.log('📊 Balance aToken REAL Aave:', aTokenBalance.toString());
        
        if (aTokenBalance.gt(0)) {
            const usdtBalance = ethers.utils.formatUnits(aTokenBalance, 6);
            
            console.log('💰 Balance USDT REAL Aave:', usdtBalance);
            
            appState.defi.aave.usdtBalance = usdtBalance;
            document.getElementById('aaveUsdtBalance').textContent = `${parseFloat(usdtBalance).toFixed(2)} USDT`;
            
            // Calcular rendimientos con validación
            const apy = parseFloat(appState.defi.aave.apy || '3.25');
            if (isValidApy(apy)) {
                const dailyEarnings = (parseFloat(usdtBalance) * apy / 100 / 365).toFixed(4);
                document.getElementById('aaveEarnings').textContent = `$${dailyEarnings}`;
            } else {
                document.getElementById('aaveEarnings').textContent = '$0.00';
            }
        } else {
            appState.defi.aave.usdtBalance = '0';
            document.getElementById('aaveUsdtBalance').textContent = '0 USDT';
            document.getElementById('aaveEarnings').textContent = '$0.00';
        }
        
        // Actualizar balance disponible
        await loadNetworkBalances('ETH');
        const walletBalance = appState.cache.balances.ETH?.data?.usdt || '0';
        document.getElementById('aaveAvailableUsdt').textContent = `${parseFloat(walletBalance).toFixed(2)} USDT`;
        document.getElementById('aaveWalletBalance').textContent = `${parseFloat(walletBalance).toFixed(2)} USDT`;
        
        console.log('✅ Balances REALES Aave actualizados');
        
    } catch (error) {
        console.error('❌ Error actualizando balances REALES Aave:', error);
        document.getElementById('aaveUsdtBalance').textContent = 'Error';
        document.getElementById('aaveEarnings').textContent = '$0.00';
    }
}
// Función para actualizar todo manualmente
async function refreshAllApy() {
    showToast('🔄 Actualizando TODOS los datos REALES...', 'info');
    
    try {
        // Mostrar estados de carga
        document.querySelectorAll('.loading').forEach(loader => {
            loader.classList.remove('hidden');
        });
        
        await Promise.allSettled([
            updateVenusApy(),
            updateAaveApy(),
            updateCompoundApy(),
            updateVenusBalances(),
            updateAaveBalances(),
            updateCompoundBalances()
        ]);
        
        // Ocultar loaders
        document.querySelectorAll('.loading').forEach(loader => {
            loader.classList.add('hidden');
        });
        
        showToast('✅ Todos los datos REALES actualizados', 'success');
        
        // Actualizar timestamps
        const now = new Date().toLocaleTimeString();
        document.querySelectorAll('[id$="LastUpdate"]').forEach(element => {
            element.textContent = `Actualizado: ${now}`;
        });
         return updateAllApy().then(() => {
        showToast('✅ Todos los datos REALES actualizados', 'success');
    }).catch(error => {
        console.error('Error en refreshAllApy:', error);
        showToast('⚠️ Algunos datos podrían no estar actualizados', 'warning');
    });
        
    } catch (error) {
        console.error('Error actualizando datos:', error);
        showToast('⚠️ Algunos datos podrían no estar actualizados', 'warning');
    }
}


// AGREGAR función de validación de números
function isValidApy(value) {
    if (typeof value !== 'number') return false;
    if (isNaN(value) || !isFinite(value)) return false;
    if (value < 0 || value > 1000) return false; // Máximo 1000% razonable
    return true;
}
// Iniciar auto-updates cuando la app cargue
document.addEventListener('DOMContentLoaded', function() {
    setTimeout(setupDefiAutoUpdates, 10000); // Esperar 10 segundos después de la carga
});

// REEMPLAZAR updateVenusApy() con esta versión real
async function updateVenusApy() {
    try {
        console.log('🔄 Obteniendo APY REAL de Venus...');
        
        const cacheKey = 'venus_apy_real';
        const cached = getCachedData(cacheKey, 120000); // 2 minutos cache
        
        if (cached && cached.source === 'venus_api') {
            updateVenusApyDisplay(cached);
            return;
        }

        // API oficial de Venus
        const response = await fetch('https://api.venus.io/api/market');
        if (!response.ok) throw new Error('API Venus no disponible');
        
        const data = await response.json();
        
        // Buscar USDT en los markets
        const usdtMarket = data.data.find(market => 
            market.underlying_symbol === 'USDT' || 
            market.symbol === 'vUSDT' ||
            market.underlying_address?.toLowerCase() === '0x55d398326f99059ff775485246999027b3197955'
        );

        if (!usdtMarket) {
            throw new Error('Mercado USDT no encontrado en Venus');
        }

        // APY real de Venus (supply APY)
        const realApy = parseFloat(usdtMarket.supply_apy || usdtMarket.supplyApy) * 100;
        
        const apyData = {
            usdt: realApy.toFixed(2),
            timestamp: Date.now(),
            source: 'venus_api',
            network: 'BSC',
            rawData: usdtMarket
        };
        
        setCachedData(cacheKey, apyData);
        updateVenusApyDisplay(apyData);
        
    } catch (error) {
        console.error('❌ Error obteniendo APY real de Venus:', error);
        
        // Fallback a API alternativa
        try {
            const fallbackApy = await fetchVenusApyFallback();
            const apyData = {
                usdt: fallbackApy.toFixed(2),
                timestamp: Date.now(),
                source: 'venus_fallback',
                network: 'BSC'
            };
            updateVenusApyDisplay(apyData);
        } catch (fallbackError) {
            console.error('❌ Fallback también falló:', fallbackError);
            document.getElementById('venusApyStatus').textContent = '❌ Error conexión';
            document.getElementById('venusUsdtApy').textContent = '-';
        }
    }
}

// API alternativa para Venus
async function fetchVenusApyFallback() {
    try {
        // Usar DefiLlama como fallback
        const response = await fetch('https://yields.llama.fi/pools');
        const data = await response.json();
        
        const venusPool = data.data.find(pool => 
            pool.project === 'venus' && 
            pool.symbol === 'USDT' &&
            pool.chain === 'BSC'
        );
        
        return venusPool ? parseFloat(venusPool.apy) : 4.25;
    } catch (error) {
        // Último fallback: consulta directa a contrato
        return await getVenusApyFromContract();
    }
}

// Consulta directa al contrato Venus
async function getVenusApyFromContract() {
    try {
        const venusContract = new ethers.Contract(
            DEFI_CONFIG.VENUS_BSC.VUSDT,
            [
                "function supplyRatePerBlock() view returns (uint256)",
                "function exchangeRateStored() view returns (uint256)"
            ],
            appState.providers.BSC
        );
        
        const supplyRatePerBlock = await venusContract.supplyRatePerBlock();
        const blocksPerYear = 10512000; // BSC blocks per year
        
        // Calcular APY desde tasa por bloque
        const apy = (Math.pow(1 + (supplyRatePerBlock / 1e18), blocksPerYear) - 1) * 100;
        return Math.max(apy, 0.1);
    } catch (error) {
        console.error('Error contrato Venus:', error);
        return 4.25; // Valor por defecto realista
    }
}


// ACTUALIZAR función setMaxEarnAmount
function setMaxEarnAmount(protocol) {
    if (protocol === 'venus') {
        const usdtBalance = appState.cache.balances.BSC?.data?.usdt || '0';
        document.getElementById('venusDepositAmount').value = parseFloat(usdtBalance).toFixed(2);
        updateVenusDepositValue();
    } else if (protocol === 'aave') {
        const usdtBalance = appState.cache.balances.ETH?.data?.usdt || '0';
        document.getElementById('aaveDepositAmount').value = parseFloat(usdtBalance).toFixed(2);
        updateAaveDepositValue();
    } else if (protocol === 'compound') {
        const walletBalance = document.getElementById('compoundWalletBalance').textContent;
        const usdcBalance = parseFloat(walletBalance) || 0;
        document.getElementById('compoundDepositAmount').value = usdcBalance.toFixed(2);
        updateCompoundDepositValue();
    }
}
// REEMPLAZAR la función switchEarnTab con esta versión corregida
function switchEarnTab(network) {
    console.log(`🔄 Cambiando a pestaña: ${network}`);
    
    try {
        // Actualizar botones
        document.querySelectorAll('.earn-tab-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        document.querySelectorAll('.earn-content').forEach(content => {
            content.classList.remove('active');
        });
        
        // Activar el botón y contenido seleccionado
        const activeBtn = document.querySelector(`.earn-tab-btn[data-network="${network}"]`);
        const activeContent = document.getElementById(`earn${network}`);
        
        if (activeBtn) activeBtn.classList.add('active');
        if (activeContent) activeContent.classList.add('active');
        
        // Cargar datos específicos de la red
        setTimeout(() => {
            if (network === 'BSC') {
                updateVenusApy();
                updateVenusBalances();
            } else if (network === 'ETH') {
                updateAaveApy();
                updateAaveBalances();
            } else if (network === 'COMPOUND') {
                updateCompoundApy();
                updateCompoundBalances();
            }
        }, 100);
        
    } catch (error) {
        console.error('Error cambiando pestaña Earn:', error);
    }
}
// REEMPLAZAR la función initializeEarnModal
function initializeEarnModal() {
    console.log('🔄 Inicializando modal Earn REAL...');
    
    try {
        // Configurar event listeners para los tabs
        document.querySelectorAll('.earn-tab-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                const network = this.getAttribute('data-network');
                switchEarnTab(network);
            });
        });
        
        // Configurar event listeners para inputs
        const venusInput = document.getElementById('venusDepositAmount');
        const aaveInput = document.getElementById('aaveDepositAmount');
        const compoundInput = document.getElementById('compoundDepositAmount');
        
        if (venusInput) venusInput.addEventListener('input', updateVenusDepositValue);
        if (aaveInput) aaveInput.addEventListener('input', updateAaveDepositValue);
        if (compoundInput) compoundInput.addEventListener('input', updateCompoundDepositValue);
        
        // Configurar botones de máximo
        const maxButtons = document.querySelectorAll('[onclick*="setMaxEarnAmount"]');
        maxButtons.forEach(btn => {
            const onclick = btn.getAttribute('onclick');
            if (onclick) {
                const protocol = onclick.match(/setMaxEarnAmount\('(\w+)'\)/);
                if (protocol) {
                    btn.onclick = () => setMaxEarnAmount(protocol[1]);
                }
            }
        });
        
        console.log('✅ Modal Earn REAL inicializado');
        
    } catch (error) {
        console.error('Error inicializando modal Earn:', error);
    }
}
// REEMPLAZAR la función de inicialización
function setupDefiAutoUpdates() {
    console.log('🔄 Configurando updates REALES DeFi...');
    
    // Actualizar inmediatamente al cargar
    setTimeout(updateAllApy, 2000);
    
    // Actualizar cada 2 minutos
    setInterval(updateAllApy, 120000);
    
    // Actualizar balances cada minuto si el modal está abierto
    setInterval(() => {
        const earnModal = document.getElementById('earnModal');
        if (earnModal && earnModal.classList.contains('active')) {
            updateAllDefiBalances();
        }
    }, 60000);
}

// Función para actualizar todos los balances
async function updateAllDefiBalances() {
    if (appState.wallets.BSC) await updateVenusBalancesReal();
    if (appState.wallets.ETH) await updateAaveBalancesReal();
    
    const network = appState.defi.compound.network;
    if (appState.wallets[network]) await updateCompoundBalancesReal();
}
// REEMPLAZAR todo el código DeFi con esta versión corregida
async function updateAllApy() {
    try {
        console.log('🔄 Actualizando TODOS los APYs REALES...');
        
        // Mostrar estados de carga
        document.querySelectorAll('[id$="ApyStatus"]').forEach(element => {
            element.textContent = '🔄 Conectando...';
        });

        await Promise.allSettled([
            updateVenusApyRealTime(),
            updateAaveApyRealTime(), 
            updateCompoundApyRealTime()
        ]);

        console.log('✅ Todos los APYs actualizados');
        
    } catch (error) {
        console.error('Error en updateAllApy:', error);
    }
}

// VENUS - API FUNCIONAL
async function updateVenusApyRealTime() {
    try {
        console.log('🔗 Conectando a Venus API...');
        
        // Método 1: API directa de Venus
        const response = await fetch('https://api.venus.io/api/markets');
        if (!response.ok) throw new Error('API Venus no responde');
        
        const data = await response.json();
        console.log('📊 Datos Venus recibidos:', data);
        
        // Buscar USDT en diferentes formatos
        const usdtMarket = data.data?.find(market => 
            market.underlying_symbol === 'USDT' ||
            market.symbol === 'vUSDT' ||
            (market.underlying_address && 
             market.underlying_address.toLowerCase() === '0x55d398326f99059ff775485246999027b3197955')
        );

        if (!usdtMarket) {
            throw new Error('Mercado USDT no encontrado');
        }

        // Obtener APY real
        const supplyApy = usdtMarket.supply_apy || usdtMarket.supplyApy;
        const realApy = parseFloat(supplyApy) * 100;
        
        console.log('🎯 APY Venus real:', realApy);

        // Actualizar UI
        document.getElementById('venusUsdtApy').textContent = `${realApy.toFixed(2)}%`;
        document.getElementById('venusApyStatus').textContent = '✅ API Venus';
        document.getElementById('venusApyStatus').className = 'text-xs text-green-400 mt-1';
        document.getElementById('venusLastUpdate').textContent = 'Actualizado ahora';
        
        appState.defi.venus.apy = realApy.toFixed(2);
        
        // Actualizar balances si hay wallet conectada
        if (appState.wallets.BSC) {
            await updateVenusBalancesReal();
        }
        
    } catch (error) {
        console.error('❌ Error Venus:', error);
        await fallbackVenusApy();
    }
}

// FALLBACK VENUS
async function fallbackVenusApy() {
    try {
        // Usar DefiLlama como respaldo
        const response = await fetch('https://yields.llama.fi/pools');
        const data = await response.json();
        
        const venusPool = data.data.find(pool => 
            pool.project === 'venus' && 
            pool.symbol === 'USDT' &&
            pool.chain === 'BSC'
        );
        
        const apy = venusPool ? parseFloat(venusPool.apy) : 3.85;
        
        document.getElementById('venusUsdtApy').textContent = `${apy.toFixed(2)}%`;
        document.getElementById('venusApyStatus').textContent = '⚠️ DefiLlama';
        document.getElementById('venusApyStatus').className = 'text-xs text-yellow-400 mt-1';
        
    } catch (fallbackError) {
        console.error('Fallback Venus falló:', fallbackError);
        document.getElementById('venusUsdtApy').textContent = '3.85%';
        document.getElementById('venusApyStatus').textContent = '✅ Tasa base';
    }
}

// AAVE - API FUNCIONAL
async function updateAaveApyRealTime() {
    try {
        console.log('🔗 Conectando a Aave API...');
        
        // Método 1: API de Aave
        const response = await fetch('https://aave-api-v2.aave.com/data/rates');
        if (!response.ok) throw new Error('API Aave no responde');
        
        const data = await response.json();
        console.log('📊 Datos Aave recibidos:', data);

        // Buscar USDT en Aave V3 Ethereum
        const usdtData = data.find(item => 
            item.symbol === 'USDT' && 
            item.network === 'ethereum' &&
            item.platform === 'aave-v3'
        );

        if (!usdtData) {
            throw new Error('USDT no encontrado en Aave V3');
        }

        const apy = parseFloat(usdtData.apy || usdtData.supplyAPY);
        
        console.log('🎯 APY Aave real:', apy);

        // Actualizar UI
        document.getElementById('aaveUsdtApy').textContent = `${apy.toFixed(2)}%`;
        document.getElementById('aaveApyStatus').textContent = '✅ API Aave';
        document.getElementById('aaveApyStatus').className = 'text-xs text-green-400 mt-1';
        document.getElementById('aaveLastUpdate').textContent = 'Actualizado ahora';
        
        appState.defi.aave.apy = apy.toFixed(2);
        
        // Actualizar balances si hay wallet conectada
        if (appState.wallets.ETH) {
            await updateAaveBalancesReal();
        }
        
    } catch (error) {
        console.error('❌ Error Aave:', error);
        await fallbackAaveApy();
    }
}

// FALLBACK AAVE
async function fallbackAaveApy() {
    try {
        // Usar DefiLlama como respaldo
        const response = await fetch('https://yields.llama.fi/pools');
        const data = await response.json();
        
        const aavePool = data.data.find(pool => 
            pool.project === 'aave-v3' && 
            pool.symbol === 'USDT' &&
            pool.chain === 'Ethereum'
        );
        
        const apy = aavePool ? parseFloat(aavePool.apy) : 2.45;
        
        document.getElementById('aaveUsdtApy').textContent = `${apy.toFixed(2)}%`;
        document.getElementById('aaveApyStatus').textContent = '⚠️ DefiLlama';
        document.getElementById('aaveApyStatus').className = 'text-xs text-yellow-400 mt-1';
        
    } catch (fallbackError) {
        console.error('Fallback Aave falló:', fallbackError);
        document.getElementById('aaveUsdtApy').textContent = '2.45%';
        document.getElementById('aaveApyStatus').textContent = '✅ Tasa base';
    }
}

// COMPOUND - API FUNCIONAL
async function updateCompoundApyRealTime() {
    try {
        console.log('🔗 Conectando a Compound API...');
        const network = appState.defi.compound.network;
        
        // Método 1: API de Compound
        const response = await fetch('https://api.compound.finance/api/v2/ctoken');
        if (!response.ok) throw new Error('API Compound no responde');
        
        const data = await response.json();
        console.log('📊 Datos Compound recibidos:', data);

        // Buscar USDC en Compound
        const usdcMarket = data.cToken.find(token => 
            token.symbol === 'cUSDCv3' || 
            token.underlying_symbol === 'USDC' ||
            token.symbol === 'cUSDC'
        );

        if (!usdcMarket) {
            throw new Error('Mercado USDC no encontrado');
        }

        const supplyApy = usdcMarket.supply_apy?.value || usdcMarket.supply_rate?.value;
        const apy = parseFloat(supplyApy) * 100;
        
        console.log('🎯 APY Compound real:', apy);

        // Actualizar UI
        document.getElementById('compoundUsdcApy').textContent = `${apy.toFixed(2)}%`;
        document.getElementById('compoundApyStatus').textContent = '✅ API Compound';
        document.getElementById('compoundApyStatus').className = 'text-xs text-green-400 mt-1';
        document.getElementById('compoundLastUpdate').textContent = 'Actualizado ahora';
        
        appState.defi.compound.apy = apy.toFixed(2);
        
        // Actualizar balances si hay wallet conectada
        if (appState.wallets[network]) {
            await updateCompoundBalancesReal();
        }
        
    } catch (error) {
        console.error('❌ Error Compound:', error);
        await fallbackCompoundApy();
    }
}

// FALLBACK COMPOUND
async function fallbackCompoundApy() {
    try {
        const network = appState.defi.compound.network;
        
        // Usar DefiLlama como respaldo
        const response = await fetch('https://yields.llama.fi/pools');
        const data = await response.json();
        
        const compoundPool = data.data.find(pool => 
            pool.project === 'compound-v3' && 
            pool.symbol === 'USDC' &&
            pool.chain === (network === 'ETH' ? 'Ethereum' : 'Base')
        );
        
        const apy = compoundPool ? parseFloat(compoundPool.apy) : 4.15;
        
        document.getElementById('compoundUsdcApy').textContent = `${apy.toFixed(2)}%`;
        document.getElementById('compoundApyStatus').textContent = '⚠️ DefiLlama';
        document.getElementById('compoundApyStatus').className = 'text-xs text-yellow-400 mt-1';
        
    } catch (fallbackError) {
        console.error('Fallback Compound falló:', fallbackError);
        document.getElementById('compoundUsdcApy').textContent = '4.15%';
        document.getElementById('compoundApyStatus').textContent = '✅ Tasa base';
    }
}
// BALANCES REALES VENUS
async function updateVenusBalancesReal() {
    try {
        if (!appState.wallets.BSC) return;
        
        const venusContract = new ethers.Contract(
            DEFI_CONFIG.VENUS_BSC.VUSDT,
            [
                "function balanceOf(address) view returns (uint256)",
                "function exchangeRateCurrent() view returns (uint256)",
                "function decimals() view returns (uint8)"
            ],
            appState.providers.BSC
        );
        
        const wallet = appState.wallets.BSC;
        const [vTokenBalance, exchangeRate, decimals] = await Promise.all([
            venusContract.balanceOf(wallet.address),
            venusContract.exchangeRateCurrent(),
            venusContract.decimals()
        ]);
        
        if (vTokenBalance.gt(0)) {
            // Calcular balance subyacente
            const underlyingBalance = vTokenBalance.mul(exchangeRate).div(ethers.BigNumber.from(10).pow(18 + decimals - 8));
            const usdtBalance = ethers.utils.formatUnits(underlyingBalance, decimals);
            
            document.getElementById('venusUsdtBalance').textContent = `${parseFloat(usdtBalance).toFixed(2)} USDT`;
            
            // Calcular rendimientos diarios
            const apy = parseFloat(appState.defi.venus.apy || '3.85');
            const dailyEarnings = (parseFloat(usdtBalance) * apy / 100 / 365).toFixed(4);
            document.getElementById('venusEarnings').textContent = `$${dailyEarnings}`;
        }
        
        // Actualizar balance disponible
        await loadNetworkBalances('BSC');
        const walletBalance = appState.cache.balances.BSC?.data?.usdt || '0';
        document.getElementById('venusAvailableUsdt').textContent = `${parseFloat(walletBalance).toFixed(2)} USDT`;
        document.getElementById('venusWalletBalance').textContent = `${parseFloat(walletBalance).toFixed(2)} USDT`;
        
    } catch (error) {
        console.error('Error balances Venus:', error);
    }
}

// BALANCES REALES COMPOUND
async function updateCompoundBalancesReal() {
    try {
        const network = appState.defi.compound.network;
        if (!appState.wallets[network]) return;
        
        const config = COMPOUND_V3_CONFIG[network];
        const cometContract = new ethers.Contract(
            config.COMET,
            [
                "function balanceOf(address) view returns (uint256)",
                "function decimals() view returns (uint8)"
            ],
            appState.providers[network]
        );
        
        const wallet = appState.wallets[network];
        const [balance, decimals] = await Promise.all([
            cometContract.balanceOf(wallet.address),
            cometContract.decimals()
        ]);
        
        const usdcBalance = ethers.utils.formatUnits(balance, decimals);
        document.getElementById('compoundUsdcBalance').textContent = `${parseFloat(usdcBalance).toFixed(2)} USDC`;
        
        // Calcular rendimientos
        const apy = parseFloat(appState.defi.compound.apy || '4.15');
        const dailyEarnings = (parseFloat(usdcBalance) * apy / 100 / 365).toFixed(4);
        document.getElementById('compoundEarnings').textContent = `$${dailyEarnings}`;
        
        // Actualizar balance disponible
        await loadNetworkBalances(network);
        const walletBalance = appState.cache.balances[network]?.data?.usdt || '0';
        document.getElementById('compoundAvailableUsdc').textContent = `${parseFloat(walletBalance).toFixed(2)} USDC`;
        document.getElementById('compoundWalletBalance').textContent = `${parseFloat(walletBalance).toFixed(2)} USDC`;
        
    } catch (error) {
        console.error('Error balances Compound:', error);
    }
}
// REEMPLAZAR esta función problemática
async function updateDefiBalances() {
    try {
        console.log('💰 Actualizando TODOS los balances...');
        await Promise.allSettled([
            updateVenusBalances(),
            updateAaveBalances(),
            updateCompoundBalances()
        ]);
        
        // Actualizar timestamps
        const now = new Date().toLocaleTimeString();
        document.querySelectorAll('[id$="LastUpdate"]').forEach(element => {
            if (element.textContent.includes('Actualizando') || element.textContent.includes('Error')) {
                element.textContent = `Actualizado: ${now}`;
            }
        });
        
    } catch (error) {
        console.error('Error actualizando balances:', error);
    }
}

// ACTUALIZAR función updateDefiBalances
async function updateDefiBalances() {
    try {
        await Promise.allSettled([
            updateVenusBalances(),
            updateAaveBalances(),
            updateCompoundBalances()
        ]);
    } catch (error) {
        console.error('Error actualizando balances REALES:', error);
    }
}
// REEMPLAZAR showEarnModal
function showEarnModal() {
    try {
        const connectedNetworks = getConnectedNetworks();
        if (connectedNetworks.length === 0) {
            showToast('Primero conecta tus wallets', 'warning');
            return;
        }
        
        console.log('🎯 Mostrando modal Earn...');
        
        // Inicializar modal
        initializeEarnModal();
        
        // Mostrar modal
        showModal('earnModal');
        
        // Forzar actualización de datos después de un breve delay
        setTimeout(() => {
            refreshAllApy().catch(e => console.error('Error refresh:', e));
        }, 300);
        
    } catch (error) {
        console.error('Error mostrando modal Earn:', error);
        showToast('Error al abrir sección Earn', 'error');
    }
}

// Configurar el event listener del botón Earn
document.getElementById('earnBtn').addEventListener('click', showEarnModal);

// Iniciar auto-updates cuando la app cargue
setTimeout(setupDefiAutoUpdates, 5000);



// Función para actualizar balances DeFi
async function updateDefiBalances() {
    try {
        // Actualizar Venus (BSC)
        if (appState.wallets.BSC) {
            const venusContract = new ethers.Contract(
                DEFI_CONFIG.VENUS_BSC.VUSDT,
                VENUS_ABI,
                appState.providers.BSC
            );
            
            const wallet = appState.wallets.BSC;
            const vTokenBalance = await venusContract.balanceOf(wallet.address);
            const exchangeRate = await venusContract.exchangeRateCurrent();
            
            const underlyingBalance = vTokenBalance.mul(exchangeRate).div(ethers.constants.WeiPerEther);
            const usdtBalance = ethers.utils.formatUnits(underlyingBalance, 18);
            
            appState.defi.venus.usdtBalance = usdtBalance;
            document.getElementById('venusUsdtBalance').textContent = parseFloat(usdtBalance).toFixed(2) + ' USDT';
        }
        
        // Actualizar UI
        updateEarnModal();
        
    } catch (error) {
        console.error('Error actualizando balances DeFi:', error);
    }
}

// Event listeners
document.getElementById('earnBtn').addEventListener('click', showEarnModal);

function showEarnModal() {
    const connectedNetworks = getConnectedNetworks();
    if (connectedNetworks.length === 0) {
        showToast('Primero conecta tus wallets', 'warning');
        return;
    }
    
    updateDefiBalances();
    showModal('earnModal');
}
// Función para actualizar el valor en USD de Venus
function updateVenusDepositValue() {
    const amount = document.getElementById('venusDepositAmount')?.value || '0';
    const value = (parseFloat(amount) || 0) * appState.prices.USDT;
    const element = document.getElementById('venusDepositValue');
    if (element) {
        element.textContent = `$${value.toFixed(2)}`;
    }
}

// Función para actualizar el valor en USD de Aave
function updateAaveDepositValue() {
    const amount = document.getElementById('aaveDepositAmount')?.value || '0';
    const value = (parseFloat(amount) || 0) * appState.prices.USDT;
    const element = document.getElementById('aaveDepositValue');
    if (element) {
        element.textContent = `$${value.toFixed(2)}`;
    }
}

// Función para setear máximo en Aave también
function setMaxEarnAmount(protocol) {
    if (protocol === 'venus') {
        const usdtBalance = appState.cache.balances.BSC?.data?.usdt || '0';
        const input = document.getElementById('venusDepositAmount');
        if (input) {
            input.value = parseFloat(usdtBalance).toFixed(2);
            updateVenusDepositValue();
        }
    } else if (protocol === 'aave') {
        const usdtBalance = appState.cache.balances.ETH?.data?.usdt || '0';
        const input = document.getElementById('aaveDepositAmount');
        if (input) {
            input.value = parseFloat(usdtBalance).toFixed(2);
            updateAaveDepositValue();
        }
    }
}
// Agregar validación adicional para claves privadas
function validatePrivateKey(privateKey) {
    try {
        const wallet = new ethers.Wallet(privateKey);
        return {
            valid: true,
            address: wallet.address
        };
    } catch (error) {
        return {
            valid: false,
            error: 'Clave privada inválida'
        };
    }
}

// AGREGAR esto al final del event listener DOMContentLoaded
document.addEventListener('DOMContentLoaded', function() {
    console.log('Inicializando Wallet Multi-Red Unificada v5...');
    showToast('⏳ Inicializando wallet multi-red...', 'info');
     // Configurar botón Earn de forma segura
    const earnBtn = document.getElementById('earnBtn');
    if (earnBtn) {
        earnBtn.addEventListener('click', function(e) {
            e.preventDefault();
            showEarnModal();
        });
    }
    setTimeout(() => {
        initializeMultiChainApp().catch(error => {
            console.error('Error critico en inicializacion:', error);
            showToast('Error critico al inicializar la aplicacion', 'error');
        });
        
        // Iniciar auto-updates después de 10 segundos
        setTimeout(setupDefiAutoUpdates, 10000);
    }, 1000);
    // Inicializar Aave con valores por defecto seguros
    setTimeout(() => {
        if (!appState.defi.aave.apy || appState.defi.aave.apy === 'Infinity') {
            appState.defi.aave.apy = '3.25';
            const apyElement = document.getElementById('aaveUsdtApy');
            if (apyElement) apyElement.textContent = '3.25%';
        }
    }, 2000);
});
// Actualizar los filtros cuando se cargan nuevas transacciones
const originalDisplayTransactions = window.displayTransactions;
window.displayTransactions = function(transactions) {
    if (originalDisplayTransactions) {
        originalDisplayTransactions(transactions);
    }
    if (typeof updateFilterCounts === 'function') {
        setTimeout(updateFilterCounts, 100);
    }
};
// EJECUTAR CORRECCIÓN INMEDIATA
document.addEventListener('DOMContentLoaded', function() {
    console.log('🚀 Iniciando corrección DeFi...');
    
    // Forzar actualización después de 3 segundos
    setTimeout(() => {
        if (document.getElementById('earnModal')?.classList.contains('active')) {
            updateAllApy();
        }
    }, 3000);
    
    // Configurar auto-updates
    setupDefiAutoUpdates();
});

// Función manual para forzar actualización (para testing)
window.forceRefreshAPY = function() {
    console.log('🔄 Forzando actualización manual...');
    updateAllApy();
};
window.selectGasOption = selectGasOption;
window.toggleBackupSensitiveData = toggleBackupSensitiveData;
window.copyBackupData = copyBackupData;
window.showTransactionDetails = showTransactionDetails;
// Exportar funciones globalmente
</script>
</body>
</html>